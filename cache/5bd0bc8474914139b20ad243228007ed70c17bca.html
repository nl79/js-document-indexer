undefined<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" />
<title>CPU cache - Wikipedia, the free encyclopedia</title>
<meta name="generator" content="MediaWiki 1.25wmf18" />
<link rel="alternate" href="android-app://org.wikipedia/http/en.m.wikipedia.org/wiki/CPU_cache" />
<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=CPU_cache&amp;action=edit" />
<link rel="edit" title="Edit this page" href="/w/index.php?title=CPU_cache&amp;action=edit" />
<link rel="apple-touch-icon" href="//bits.wikimedia.org/apple-touch/wikipedia.png" />
<link rel="shortcut icon" href="//bits.wikimedia.org/favicon/wikipedia.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
<link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="/wiki/CPU_cache" />
<link rel="copyright" href="//creativecommons.org/licenses/by-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="canonical" href="http://en.wikipedia.org/wiki/CPU_cache" />
<link rel="stylesheet" href="//bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=ext.gadget.DRN-wizard%2CReferenceTooltips%2Ccharinsert%2Cfeatured-articles-links%2CrefToolbar%2Cswitcher%2Cteahouse%7Cext.math.styles%7Cext.rtlcite%2Cwikihiero%2CwikimediaBadges%7Cext.uls.nojs%7Cext.visualEditor.viewPageTarget.noscript%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles%7Cwikibase.client.init&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="//bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: enwiki:resourceloader:filter:minify-css:7:3904d24a08aa08f6a68dc338f9be277e */</style>
<script src="//bits.wikimedia.org/en.wikipedia.org/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"CPU_cache","wgTitle":"CPU cache","wgCurRevisionId":649703928,"wgRevisionId":649703928,"wgArticleId":849181,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages containing cite templates with deprecated parameters","All articles with dead external links","Articles with dead external links from July 2013","Articles to be merged from July 2013","All articles to be merged","All articles with unsourced statements","Articles with unsourced statements from March 2008","All accuracy disputes","Articles with disputed statements from December 2010","Central processing unit","Computer memory","Cache (computing)"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"CPU_cache","wgRelevantArticleId":849181,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":false,"publish":false},"wgBetaFeaturesFeatures":[],"wgMediaViewerOnClick":true,"wgMediaViewerEnabledByDefault":true,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr"},"wikilove-recipient":"","wikilove-anon":0,"wgPoweredByHHVM":true,"wgULSAcceptLanguageList":["en-us","en"],"wgULSCurrentAutonym":"English","wgFlaggedRevsParams":{"tags":{"status":{"levels":1,"quality":2,"pristine":3}}},"wgStableRevisionId":null,"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","wgNoticeProject":"wikipedia","wgWikibaseItemId":"Q352090"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});},{},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});},{},{},{});
/* cache key: enwiki:resourceloader:filter:minify-js:7:94007ea073e20ad4a3cdce36b2f2e369 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","ext.centralauth.centralautologin","mmv.head","ext.imageMetrics.head","ext.visualEditor.viewPageTarget.init","ext.uls.init","ext.uls.interface","ext.centralNotice.bannerController","skins.vector.js"]);
}</script>
<link rel="dns-prefetch" href="//meta.wikimedia.org" />
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/w/static-1.25wmf18/skins/Vector/csshover.min.htc")}</style><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-CPU_cache skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>

							<div id="siteNotice"><!-- CentralNotice --></div>
						<div class="mw-indicators">
</div>
			<h1 id="firstHeading" class="firstHeading" lang="en">CPU cache</h1>
						<div id="bodyContent" class="mw-body-content">
									<div id="siteSub">From Wikipedia, the free encyclopedia</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="hatnote">"Cache memory" redirects here. For the general use in computing, see <a href="/wiki/Cache_(computing)" title="Cache (computing)">Cache (computing)</a>.</div>
<table class="metadata plainlinks ambox ambox-move" role="presentation">
<tr>
<td class="mbox-image">
<div style="width:52px"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/50px-Mergefrom.svg.png" width="50" height="20" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/75px-Mergefrom.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/100px-Mergefrom.svg.png 2x" data-file-width="50" data-file-height="20" /></div>
</td>
<td class="mbox-text"><span class="mbox-text-span">It has been suggested that <i><a href="/wiki/Tag_RAM" title="Tag RAM">Tag RAM</a></i> be <a href="/wiki/Wikipedia:Merging" title="Wikipedia:Merging">merged</a> into this article. (<a href="/wiki/Talk:CPU_cache#Proposed_merge_with_Tag_RAM" title="Talk:CPU cache">Discuss</a>) <small><i>Proposed since July 2013.</i></small></span></td>
</tr>
</table>
<p>A <b>CPU cache</b> is a <a href="/wiki/Cache_(computing)" title="Cache (computing)">cache</a> used by the <a href="/wiki/Central_processing_unit" title="Central processing unit">central processing unit</a> (CPU) of a <a href="/wiki/Computer" title="Computer">computer</a> to reduce the average time to access data from the <a href="/wiki/Main_memory" title="Main memory" class="mw-redirect">main memory</a>. The cache is a smaller, faster memory which stores copies of the data from frequently used <a href="/wiki/Main_memory" title="Main memory" class="mw-redirect">main memory</a> locations. Most CPUs have different independent caches, including instruction and data caches, where the data cache is usually organized as a hierarchy of more cache levels (L1, L2 etc.)</p>
<p></p>
<div id="toc" class="toc">
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Cache_entries"><span class="tocnumber">1.1</span> <span class="toctext">Cache entries</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Cache_performance"><span class="tocnumber">1.2</span> <span class="toctext">Cache performance</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#Replacement_policies"><span class="tocnumber">1.2.1</span> <span class="toctext">Replacement policies</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Write_policies"><span class="tocnumber">1.2.2</span> <span class="toctext">Write policies</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#CPU_stalls"><span class="tocnumber">1.2.3</span> <span class="toctext">CPU stalls</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Cache_entry_structure"><span class="tocnumber">2</span> <span class="toctext">Cache entry structure</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Example"><span class="tocnumber">2.1</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Flag_bits"><span class="tocnumber">2.2</span> <span class="toctext">Flag bits</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Associativity"><span class="tocnumber">3</span> <span class="toctext">Associativity</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Direct-mapped_cache"><span class="tocnumber">3.1</span> <span class="toctext">Direct-mapped cache</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Two-way_set_associative_cache"><span class="tocnumber">3.2</span> <span class="toctext">Two-way set associative cache</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Speculative_execution"><span class="tocnumber">3.3</span> <span class="toctext">Speculative execution</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Two-way_skewed_associative_cache"><span class="tocnumber">3.4</span> <span class="toctext">Two-way skewed associative cache</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Pseudo-associative_cache"><span class="tocnumber">3.5</span> <span class="toctext">Pseudo-associative cache</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Cache_miss"><span class="tocnumber">4</span> <span class="toctext">Cache miss</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Address_translation"><span class="tocnumber">5</span> <span class="toctext">Address translation</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Homonym_and_synonym_problems"><span class="tocnumber">5.1</span> <span class="toctext">Homonym and synonym problems</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Virtual_tags_and_vhints"><span class="tocnumber">5.2</span> <span class="toctext">Virtual tags and vhints</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Page_coloring"><span class="tocnumber">5.3</span> <span class="toctext">Page coloring</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="#Cache_hierarchy_in_a_modern_processor"><span class="tocnumber">6</span> <span class="toctext"> Cache hierarchy in a modern processor</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#Specialized_caches"><span class="tocnumber">6.1</span> <span class="toctext">Specialized caches</span></a>
<ul>
<li class="toclevel-3 tocsection-23"><a href="#Victim_cache"><span class="tocnumber">6.1.1</span> <span class="toctext">Victim cache</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#Trace_cache"><span class="tocnumber">6.1.2</span> <span class="toctext">Trace cache</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Micro-operation_.28uop.29_cache"><span class="tocnumber">6.1.3</span> <span class="toctext">Micro-operation (uop) cache</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26"><a href="#Multi-level_caches"><span class="tocnumber">6.2</span> <span class="toctext">Multi-level caches</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="#Multi-core_chips"><span class="tocnumber">6.2.1</span> <span class="toctext">Multi-core chips</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Separate_versus_unified"><span class="tocnumber">6.2.2</span> <span class="toctext">Separate versus unified</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#Exclusive_versus_inclusive"><span class="tocnumber">6.2.3</span> <span class="toctext">Exclusive versus inclusive</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-30"><a href="#Example:_the_K8"><span class="tocnumber">6.3</span> <span class="toctext">Example: the K8</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#More_hierarchies"><span class="tocnumber">6.4</span> <span class="toctext">More hierarchies</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="#Implementation"><span class="tocnumber">7</span> <span class="toctext">Implementation</span></a>
<ul>
<li class="toclevel-2 tocsection-33"><a href="#History"><span class="tocnumber">7.1</span> <span class="toctext">History</span></a>
<ul>
<li class="toclevel-3 tocsection-34"><a href="#First_TLB_implementations"><span class="tocnumber">7.1.1</span> <span class="toctext">First TLB implementations</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#First_data_cache"><span class="tocnumber">7.1.2</span> <span class="toctext">First data cache</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#In_68k_microprocessors"><span class="tocnumber">7.1.3</span> <span class="toctext">In 68k microprocessors</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#In_x86_microprocessors"><span class="tocnumber">7.1.4</span> <span class="toctext">In x86 microprocessors</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#Current_research"><span class="tocnumber">7.1.5</span> <span class="toctext">Current research</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-39"><a href="#Multi-ported_cache"><span class="tocnumber">7.2</span> <span class="toctext">Multi-ported cache</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-41"><a href="#Notes"><span class="tocnumber">9</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-42"><a href="#References"><span class="tocnumber">10</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-43"><a href="#External_links"><span class="tocnumber">11</span> <span class="toctext">External links</span></a></li>
</ul>
</div>
<p></p>
<h2><span class="mw-headline" id="Overview"><span id="ICACHE"></span><span id="DCACHE"></span><span id="instruction_cache"></span><span id="data_cache"></span>Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When the processor needs to read from or write to a location in main memory, it first checks whether a copy of that data is in the cache. If so, the processor immediately reads from or writes to the cache, which is much faster than reading from or writing to main memory.</p>
<p>Most modern desktop and server CPUs have at least three independent caches: an <b>instruction cache</b> to speed up executable instruction fetch, a <b>data cache</b> to speed up data fetch and store, and a <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">translation lookaside buffer</a> (TLB) used to speed up virtual-to-physical address translation for both executable instructions and data. The data cache is usually organized as a hierarchy of more cache levels (L1, L2, etc.; see also <a href="#Multi-level_caches">multi-level caches</a> below).</p>
<h3><span class="mw-headline" id="Cache_entries"><span id="cache_lines"></span><span id="CACHE-LINES"></span>Cache entries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=2" title="Edit section: Cache entries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Data is transferred between memory and cache in blocks of fixed size, called <i>cache lines</i>. When a cache line is copied from memory into the cache, a cache entry is created. The cache entry will include the copied data as well as the requested memory location (now called a tag).</p>
<p>When the processor needs to read or write a location in main memory, it first checks for a corresponding entry in the cache. The cache checks for the contents of the requested memory location in any cache lines that might contain that address. If the processor finds that the memory location is in the cache, a cache hit has occurred. However, if the processor does not find the memory location in the cache, a cache miss has occurred. In the case of:</p>
<ul>
<li>a cache hit, the processor immediately reads or writes the data in the cache line</li>
<li>a cache miss, the cache allocates a new entry and copies in data from main memory, then the request is fulfilled from the contents of the cache.</li>
</ul>
<h3><span class="mw-headline" id="Cache_performance">Cache performance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=3" title="Edit section: Cache performance">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The proportion of accesses that result in a cache hit is known as the hit rate, and can be a measure of the effectiveness of the cache for a given program or algorithm.</p>
<p>Read misses delay execution because they require data to be transferred from memory, which is much slower than reading from the cache. Write misses may occur without such penalty, since the processor can continue execution while data is copied to main memory in the background.</p>
<h4><span class="mw-headline" id="Replacement_policies"><span id="EVICTION"></span>Replacement policies</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=4" title="Edit section: Replacement policies">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="hatnote relarticle mainarticle">Main article: <a href="/wiki/Cache_algorithms" title="Cache algorithms">Cache algorithms</a></div>
<p>In order to make room for the new entry on a cache miss, the cache may have to evict one of the existing entries. The heuristic that it uses to choose the entry to evict is called the replacement policy. The fundamental problem with any replacement policy is that it must predict which existing cache entry is least likely to be used in the future. Predicting the future is difficult, so there is no perfect way to choose among the variety of replacement policies available.</p>
<p>One popular replacement policy, least-recently used (LRU), replaces the least recently accessed entry.</p>
<p>Marking some memory ranges as non-cacheable can improve performance, by avoiding caching of memory regions that are rarely re-accessed. This avoids the overhead of loading something into the cache without having any reuse.</p>
<ul>
<li>Cache entries may also be disabled or locked depending on the context.</li>
</ul>
<h4><span class="mw-headline" id="Write_policies">Write policies</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=5" title="Edit section: Write policies">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="hatnote relarticle mainarticle">Main article: <a href="/wiki/Cache_(computing)#WRITEPOLICIES" title="Cache (computing)">Cache: Writing policies</a></div>
<p>If data is written to the cache, at some point it must also be written to main memory. The timing of this write is known as the write policy.</p>
<ul>
<li>In a <a href="/wiki/Write-through" title="Write-through" class="mw-redirect">write-through</a> cache, every write to the cache causes a write to main memory.</li>
<li>Alternatively, in a <a href="/wiki/Write-back" title="Write-back" class="mw-redirect">write-back</a> or copy-back cache, writes are not immediately mirrored to the main memory. Instead, the cache tracks which locations have been written over (these locations are marked <a href="/wiki/Dirty_bit" title="Dirty bit">dirty</a>). The data in these locations are written back to the main memory only when that data is evicted from the cache. For this reason, a read miss in a write-back cache may sometimes require two memory accesses to service: one to first write the dirty location to memory and then another to read the new location from memory. Also, a write can evict the dirty location: writing to a different RAM memory location not mapped yet to the cache, leading to a capacity miss on a dirty cache line will lead first to the eviction of that dirty cache line.</li>
</ul>
<p>There are intermediate policies as well. The cache may be write-through, but the writes may be held in a store data queue temporarily, usually so that multiple stores can be processed together (which can reduce bus turnarounds and improve bus utilization).</p>
<p>The data in main memory being cached may be changed by other entities (e.g. peripherals using <a href="/wiki/Direct_memory_access" title="Direct memory access">direct memory access</a> or <a href="/wiki/Multi-core_processor" title="Multi-core processor">multi-core processor</a>), in which case the copy in the cache may become out-of-date or stale. Alternatively, when a CPU in a <a href="/wiki/Multiprocessor" title="Multiprocessor" class="mw-redirect">multiprocessor</a> system updates data in the cache, copies of data in caches associated with other CPUs will become stale. Communication protocols between the cache managers which keep the data consistent are known as <a href="/wiki/Cache_coherence" title="Cache coherence">cache coherence</a> protocols.</p>
<h4><span class="mw-headline" id="CPU_stalls">CPU stalls</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=6" title="Edit section: CPU stalls">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The time taken to fetch one cache line from memory (read latency) matters because the CPU will run out of things to do while waiting for the cache line. When a CPU reaches this state, it is called a stall. As CPUs become faster compared to main memory, stalls due to cache misses displace more potential computation; modern CPUs can execute hundreds of instructions in the time taken to fetch a single cache line from main memory.</p>
<p>Various techniques have been employed to keep the CPU busy during this time, including <a href="/wiki/Out-of-order_execution" title="Out-of-order execution">out-of-order execution</a> in which the CPU (Pentium Pro and later Intel designs, for example) attempts to execute independent instructions after the instruction that is waiting for the cache miss data. Another technology, used by many processors, is <a href="/wiki/Simultaneous_multithreading" title="Simultaneous multithreading">simultaneous multithreading</a> (SMT), or—​in Intel's terminology—​<a href="/wiki/Hyper-threading" title="Hyper-threading">hyper-threading</a> (HT), which allows an alternate thread to use the CPU core while the first thread waits for required CPU resources to become available.</p>
<h2><span class="mw-headline" id="Cache_entry_structure">Cache entry structure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=7" title="Edit section: Cache entry structure">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Cache row entries usually have the following structure:</p>
<table style="width:30%; text-align:center" border="1">
<tr>
<td>tag</td>
<td>data block</td>
<td>flag bits</td>
</tr>
</table>
<p>The <i>data block</i> (cache line) contains the actual data fetched from the main memory. The <i>tag</i> contains (part of) the address of the actual data fetched from the main memory. The flag bits are discussed below.</p>
<p>The "size" of the cache is the amount of main memory data it can hold. This size can be calculated as the number of bytes stored in each data block times the number of blocks stored in the cache. (The tag, flag and <a href="/wiki/ECC_memory#cache" title="ECC memory">error correction code</a> bits are not included in the size,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1"><span>[</span>1<span>]</span></a></sup> although they do affect the physical area of a cache.)</p>
<p>An effective memory address is split (<a href="/wiki/Most_significant_bit" title="Most significant bit">MSB</a> to <a href="/wiki/Least_significant_bit" title="Least significant bit">LSB</a>) into the tag, the index and the block offset.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2"><span>[</span>2<span>]</span></a></sup><sup id="cite_ref-3" class="reference"><a href="#cite_note-3"><span>[</span>3<span>]</span></a></sup></p>
<table style="width:30%; text-align:center" border="1">
<tr>
<td>tag</td>
<td>index</td>
<td>block offset</td>
</tr>
</table>
<p>The index describes which cache row (which cache line) that the data has been put in. The index length is <img class="mwe-math-fallback-image-inline tex" alt="\lceil \log_2(r) \rceil" src="//upload.wikimedia.org/math/1/f/d/1fdfe44d4276dc9510cb314fd317c44d.png" /> bits for <span class="texhtml mvar" style="font-style:italic;">r</span> cache rows.</p>
<p>The block offset specifies the desired data within the stored data block within the cache row. Typically the effective address is in bytes, so the block offset length is <img class="mwe-math-fallback-image-inline tex" alt="\lceil \log_2(b) \rceil" src="//upload.wikimedia.org/math/7/a/9/7a96b45388644a667e25c2de59d7f811.png" /> bits, where <span class="texhtml mvar" style="font-style:italic;">b</span> is the number of bytes per data block. The tag contains the most significant bits of the address, which are checked against the current row (the row has been retrieved by index) to see if it is the one we need or another, irrelevant memory location that happened to have the same index bits as the one we want. The tag length in bits is <code>address_length - index_length - block_offset_length</code>.</p>
<p>Some authors refer to the block offset as simply the "offset"<sup id="cite_ref-ccs.neu.edu_4-0" class="reference"><a href="#cite_note-ccs.neu.edu-4"><span>[</span>4<span>]</span></a></sup> or the "displacement".<sup id="cite_ref-5" class="reference"><a href="#cite_note-5"><span>[</span>5<span>]</span></a></sup><sup id="cite_ref-6" class="reference"><a href="#cite_note-6"><span>[</span>6<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Example">Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=8" title="Edit section: Example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The original <a href="/wiki/Pentium_4" title="Pentium 4">Pentium 4</a> processor had a four-way set associative L1 data cache of 8&#160;<a href="/wiki/Kibibyte" title="Kibibyte">KB</a> in size, with 64-byte cache blocks. Hence, there are 8&#160;KB&#160;/&#160;64&#160;=&#160;128 cache blocks. The number of sets is equal to the number of cache blocks divided by the number of ways of associativity, what leads to 128&#160;/&#160;4&#160;=&#160;32 sets, and hence 2<sup>5</sup>&#160;=&#160;32 different indices. There are 2<sup>6</sup>&#160;=&#160;64 possible offsets. Since the CPU address is 32 bits wide, this implies 21&#160;+&#160;5&#160;+&#160;6&#160;=&#160;32, and hence 21 bits for the tag field.</p>
<p>The original Pentium&#160;4 processor also had an eight-way set associative L2 integrated cache 256&#160;KB in size, with 128-byte cache blocks. This implies 17&#160;+&#160;8&#160;+&#160;7&#160;=&#160;32, and hence 17 bits for the tag field.<sup id="cite_ref-ccs.neu.edu_4-1" class="reference"><a href="#cite_note-ccs.neu.edu-4"><span>[</span>4<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Flag_bits">Flag bits</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=9" title="Edit section: Flag bits">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An instruction cache requires only one flag bit per cache row entry: a valid bit. The valid bit indicates whether or not a cache block has been loaded with valid data.</p>
<p>On power-up, the hardware sets all the valid bits in all the caches to "invalid". Some systems also set a valid bit to "invalid" at other times, such as when multi-master <a href="/wiki/Bus_snooping" title="Bus snooping" class="mw-redirect">bus snooping</a> hardware in the cache of one processor hears an address broadcast from some other processor, and realizes that certain data blocks in the local cache are now stale and should be marked invalid.</p>
<p>A data cache typically requires two flag bits per cache line&#160;–  a valid bit and a <a href="/wiki/Dirty_bit" title="Dirty bit">dirty bit</a>. Having a dirty bit set indicates that the associated cache line has been changed since it was read from main memory ("dirty"), meaning that the processor has written data to that line and the new value has not propagated all the way to main memory.</p>
<h2><span class="mw-headline" id="Associativity">Associativity</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=10" title="Edit section: Associativity">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:452px;"><a href="/wiki/File:Cache,associative-fill-both.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/9/93/Cache%2Cassociative-fill-both.png/450px-Cache%2Cassociative-fill-both.png" width="450" height="223" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/9/93/Cache%2Cassociative-fill-both.png 1.5x, //upload.wikimedia.org/wikipedia/commons/9/93/Cache%2Cassociative-fill-both.png 2x" data-file-width="546" data-file-height="271" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Cache,associative-fill-both.png" class="internal" title="Enlarge"></a></div>
An illustration of different ways in which memory locations can be cached by particular cache locations</div>
</div>
</div>
<p>The replacement policy decides where in the cache a copy of a particular entry of main memory will go. If the replacement policy is free to choose any entry in the cache to hold the copy, the cache is called <i>fully associative</i>. At the other extreme, if each entry in main memory can go in just one place in the cache, the cache is <i>direct mapped</i>. Many caches implement a compromise in which each entry in main memory can go to any one of N places in the cache, and are described as N-way set associative.<sup id="cite_ref-7" class="reference"><a href="#cite_note-7"><span>[</span>7<span>]</span></a></sup> For example, the level-1 data cache in an <a href="/wiki/AMD_Athlon" title="AMD Athlon" class="mw-redirect">AMD Athlon</a> is two-way set associative, which means that any particular location in main memory can be cached in either of two locations in the level-1 data cache.</p>
<p>Associativity is a <a href="/wiki/Trade-off" title="Trade-off">trade-off</a>. If there are ten places to which the replacement policy could have mapped a memory location, then to check if that location is in the cache, ten cache entries must be searched. Checking more places takes more power, chip area, and potentially time. On the other hand, caches with more associativity suffer fewer misses (see conflict misses, below), so that the CPU wastes less time reading from the slow main memory. The rule of thumb is that doubling the associativity, from direct mapped to two-way, or from two-way to four-way, has about the same effect on hit rate as doubling the cache size. Associativity increases beyond four-way have much less effect on the hit rate,<sup id="cite_ref-8" class="reference"><a href="#cite_note-8"><span>[</span>8<span>]</span></a></sup> and are generally done for other reasons (see virtual aliasing, below).</p>
<p>In order of worse but simple to better but complex:</p>
<ul>
<li>direct mapped cache&#160;–  good best-case time, but flaky in worse case</li>
<li>two-way set associative cache</li>
<li>two-way skewed associative cache<sup id="cite_ref-Seznec_9-0" class="reference"><a href="#cite_note-Seznec-9"><span>[</span>9<span>]</span></a></sup></li>
<li>four-way set associative cache</li>
<li>eight-way set associative cache, a common choice for later implementations</li>
<li>12-way set associative cache, similar to eight-way</li>
<li>fully associative cache&#160;–  the best miss rates, but practical only for a small number of entries</li>
</ul>
<h3><span class="mw-headline" id="Direct-mapped_cache">Direct-mapped cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=11" title="Edit section: Direct-mapped cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this cache organization, each location in main memory can only go in one entry in the cache. Therefore, a direct-mapped cache can also be called a "one-way set associative" cache. It does not have a replacement policy as such, since there is no choice of which cache entry's contents to evict. This means that if two locations map to the same entry, they may continually knock each other out. Although simpler, a direct-mapped cache needs to be much larger than an associative one to give comparable performance, and it is more unpredictable. Let <span class="texhtml mvar" style="font-style:italic;">x</span> be block number in cache, <span class="texhtml mvar" style="font-style:italic;">y</span> be block number of memory, and <span class="texhtml mvar" style="font-style:italic;">n</span> be number of blocks in cache, then mapping is done with the help of the equation <span class="texhtml mvar" style="font-style:italic;">x = y mod n</span>.</p>
<h3><span class="mw-headline" id="Two-way_set_associative_cache">Two-way set associative cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=12" title="Edit section: Two-way set associative cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If each location in main memory can be cached in either of two locations in the cache, one logical question is: <i>which one of the two?</i> The simplest and most commonly used scheme, shown in the right-hand diagram above, is to use the least significant bits of the memory location's index as the index for the cache memory, and to have two entries for each index. One benefit of this scheme is that the tags stored in the cache do not have to include that part of the main memory address which is implied by the cache memory's index. Since the cache tags have fewer bits, they require fewer transistors, take less space on the processor circuit board or on the microprocessor chip, and can be read and compared faster. Also <a href="/wiki/Cache_algorithms" title="Cache algorithms">LRU</a> is especially simple since only one bit needs to be stored for each pair.</p>
<h3><span class="mw-headline" id="Speculative_execution">Speculative execution</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=13" title="Edit section: Speculative execution">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>One of the advantages of a direct mapped cache is that it allows simple and fast <a href="/wiki/Speculative_execution" title="Speculative execution">speculation</a>. Once the address has been computed, the one cache index which might have a copy of that location in memory is known. That cache entry can be read, and the processor can continue to work with that data before it finishes checking that the tag actually matches the requested address.</p>
<p>The idea of having the processor use the cached data before the tag match completes can be applied to associative caches as well. A subset of the tag, called a <i>hint</i>, can be used to pick just one of the possible cache entries mapping to the requested address. The entry selected by the hint can then be used in parallel with checking the full tag. The hint technique works best when used in the context of address translation, as explained below.</p>
<h3><span class="mw-headline" id="Two-way_skewed_associative_cache">Two-way skewed associative cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=14" title="Edit section: Two-way skewed associative cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Other schemes have been suggested, such as the <i>skewed cache</i>,<sup id="cite_ref-Seznec_9-1" class="reference"><a href="#cite_note-Seznec-9"><span>[</span>9<span>]</span></a></sup> where the index for way 0 is direct, as above, but the index for way 1 is formed with a <a href="/wiki/Hash_function" title="Hash function">hash function</a>. A good hash function has the property that addresses which conflict with the direct mapping tend not to conflict when mapped with the hash function, and so it is less likely that a program will suffer from an unexpectedly large number of conflict misses due to a pathological access pattern. The downside is extra latency from computing the hash function.<sup id="cite_ref-CK_10-0" class="reference"><a href="#cite_note-CK-10"><span>[</span>10<span>]</span></a></sup> Additionally, when it comes time to load a new line and evict an old line, it may be difficult to determine which existing line was least recently used, because the new line conflicts with data at different indexes in each way; <a href="/wiki/Cache_algorithms" title="Cache algorithms">LRU</a> tracking for non-skewed caches is usually done on a per-set basis. Nevertheless, skewed-associative caches have major advantages over conventional set-associative ones.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11"><span>[</span>11<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Pseudo-associative_cache">Pseudo-associative cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=15" title="Edit section: Pseudo-associative cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A true set-associative cache tests all the possible ways simultaneously, using something like a <a href="/wiki/Content_addressable_memory" title="Content addressable memory" class="mw-redirect">content addressable memory</a>. A pseudo-associative cache tests each possible way one at a time. A hash-rehash cache and a column-associative cache are examples of a pseudo-associative cache.</p>
<p>In the common case of finding a hit in the first way tested, a pseudo-associative cache is as fast as a direct-mapped cache, but it has a much lower conflict miss rate than a direct-mapped cache, closer to the miss rate of a fully associative cache. <sup id="cite_ref-CK_10-1" class="reference"><a href="#cite_note-CK-10"><span>[</span>10<span>]</span></a></sup></p>
<h2><span class="mw-headline" id="Cache_miss"><span id="CACHE-MISS"></span>Cache miss</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=16" title="Edit section: Cache miss">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A cache miss refers to a failed attempt to read or write a piece of data in the cache, which results in a main memory access with much longer latency. There are three kinds of cache misses: instruction read miss, data read miss, and data write miss.</p>
<p>A <i>cache read miss</i> from an <i>instruction</i> cache generally causes the most delay, because the processor, or at least the <a href="/wiki/Simultaneous_multithreading" title="Simultaneous multithreading">thread of execution</a>, has to wait (stall) until the instruction is fetched from main memory.</p>
<p>A <i>cache read miss</i> from a <i>data</i> cache usually causes less delay, because instructions not dependent on the cache read can be issued and continue execution until the data is returned from main memory, and the dependent instructions can resume execution.</p>
<p>A <i>cache write miss</i> to a <i>data</i> cache generally causes the least delay, because the write can be queued and there are few limitations on the execution of subsequent instructions. The processor can continue until the queue is full.</p>
<p>In order to lower cache miss rate, a great deal of analysis has been done on cache behavior in an attempt to find the best combination of size, associativity, block size, and so on. Sequences of memory references performed by benchmark programs are saved as <i>address traces</i>. Subsequent analyses simulate many different possible cache designs on these long address traces. Making sense of how the many variables affect the cache hit rate can be quite confusing. One significant contribution to this analysis was made by <a rel="nofollow" class="external text" href="http://www.cs.wisc.edu/~markhill">Mark Hill</a>, who separated misses into three categories (known as the Three Cs):</p>
<ul>
<li><i>Compulsory misses</i> are those misses caused by the first reference to a location in memory that a program has never requested before. Cache size and associativity make no difference to the number of compulsory misses. Prefetching can help here, as can larger cache block sizes (which are a form of prefetching). Compulsory misses are sometimes referred to as <i>cold misses</i>.</li>
<li><i>Capacity misses</i> are those misses that occur regardless of associativity or block size, solely due to the finite size of the cache. The curve of capacity miss rate versus cache size gives some measure of the temporal locality of a particular reference stream. Note that there is no useful notion of a cache being "full" or "empty" or "near capacity": CPU caches almost always have nearly every line filled with a copy of some line in main memory, and nearly every allocation of a new line requires the eviction of an old line.</li>
<li><i>Conflict misses</i> are those misses that could have been avoided, had the cache not evicted an entry earlier. Conflict misses can be further broken down into <i>mapping misses</i>, that are unavoidable given a particular amount of associativity, and <i>replacement misses</i>, which are due to the particular victim choice of the replacement policy.</li>
</ul>
<div class="thumb tright">
<div class="thumbinner" style="width:402px;"><a href="/wiki/File:Cache,missrate.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/0/07/Cache%2Cmissrate.png/400px-Cache%2Cmissrate.png" width="400" height="254" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/0/07/Cache%2Cmissrate.png 1.5x, //upload.wikimedia.org/wikipedia/commons/0/07/Cache%2Cmissrate.png 2x" data-file-width="453" data-file-height="288" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Cache,missrate.png" class="internal" title="Enlarge"></a></div>
Miss rate versus cache size on the Integer portion of SPEC CPU2000</div>
</div>
</div>
<p>The graph to the right summarizes the cache performance seen on the Integer portion of the SPEC CPU2000 benchmarks, as collected by Hill and Cantin.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12"><span>[</span>12<span>]</span></a></sup> These <a href="/wiki/Benchmark_(computing)" title="Benchmark (computing)">benchmarks</a> are intended to represent the kind of workload that an engineering workstation computer might see on any given day. The reader should keep in mind that finding benchmarks which are even usefully representative of many programs has been very difficult, and there will always be important programs with very different behavior than what is shown here.</p>
<p>We can see the different effects of the three Cs in this graph.</p>
<p>At the far right, with cache size labelled "Inf", we have the compulsory misses. If we wish to improve a machine's performance on SpecInt2000, increasing the cache size beyond 1&#160;<a href="/wiki/Mebibyte" title="Mebibyte">MB</a> is essentially futile. That is the insight given by the compulsory misses.</p>
<p>The fully associative cache miss rate here is almost representative of the capacity miss rate. The difference is that the data presented is from simulations assuming an <a href="/wiki/Cache_algorithms" title="Cache algorithms">LRU</a> replacement policy. Showing the capacity miss rate would require a <a href="/wiki/Page_replacement_algorithm#The_theoretically_optimal_page_replacement_algorithm" title="Page replacement algorithm">perfect replacement policy</a>, i.e. an oracle that looks into the future to find a cache entry which is actually not going to be hit.</p>
<p>Note that our approximation of the capacity miss rate falls steeply between 32&#160;KB and 64&#160;KB. This indicates that the benchmark has a <i><a href="/wiki/Working_set" title="Working set">working set</a></i> of roughly 64&#160;KB. A CPU cache designer examining this benchmark will have a strong incentive to set the cache size to 64&#160;KB rather than 32&#160;KB. Note that, on this benchmark, no amount of associativity can make a 32&#160;KB cache perform as well as a 64&#160;KB 4-way, or even a direct-mapped 128&#160;KB cache.</p>
<p>Finally, note that between 64&#160;KB and 1&#160;MB there is a large difference between direct-mapped and fully associative caches. This difference is the conflict miss rate. The insight from looking at conflict miss rates is that secondary caches benefit a great deal from high associativity.</p>
<p>This benefit was well known in the late 1980s and early 1990s, when CPU designers could not fit large caches on-chip, and could not get sufficient bandwidth to either the cache data memory or cache tag memory to implement high associativity in off-chip caches. Desperate hacks were attempted: the <a href="/wiki/MIPS_architecture" title="MIPS architecture" class="mw-redirect">MIPS</a> <a href="/wiki/R8000" title="R8000">R8000</a> used expensive off-chip dedicated tag <a href="/wiki/Static_random_access_memory" title="Static random access memory" class="mw-redirect">SRAMs</a>, which had embedded tag comparators and large drivers on the match lines, in order to implement a 4&#160;MB four-way associative cache. The MIPS <a href="/wiki/R10000" title="R10000">R10000</a> used ordinary SRAM chips for the tags. Tag access for both ways took two cycles. To reduce latency, the R10000 would guess which way of the cache would hit on each access.</p>
<h2><span class="mw-headline" id="Address_translation"><span id="ADDRTRANS"></span>Address translation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=17" title="Edit section: Address translation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Most general purpose CPUs implement some form of <a href="/wiki/Virtual_memory" title="Virtual memory">virtual memory</a>. To summarize, either each program running on the machine sees its own simplified <a href="/wiki/Address_space" title="Address space">address space</a>, which contains code and data for that program only, or all programs run in a common virtual address space. A program uses the virtual address space in which it runs without regard for where particular locations in that address space exist in physical memory.</p>
<p>Virtual memory requires the processor to translate virtual addresses generated by the program into physical addresses in main memory. The portion of the processor that does this translation is known as the <a href="/wiki/Memory_management_unit" title="Memory management unit">memory management unit</a> (MMU). The fast path through the MMU can perform those translations stored in the <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">translation lookaside buffer</a> (TLB), which is a cache of mappings from the operating system's <a href="/wiki/Page_table" title="Page table">page table</a>, segment table or both.</p>
<p>For the purposes of the present discussion, there are three important features of address translation:</p>
<ul>
<li><i>Latency:</i> The physical address is available from the MMU some time, perhaps a few cycles, after the virtual address is available from the address generator.</li>
</ul>
<ul>
<li><i>Aliasing:</i> Multiple virtual addresses can map to a single physical address. Most processors guarantee that all updates to that single physical address will happen in program order. To deliver on that guarantee, the processor must ensure that only one copy of a physical address resides in the cache at any given time.</li>
</ul>
<ul>
<li><i>Granularity:</i> The virtual address space is broken up into pages. For instance, a 4&#160;<a href="/wiki/Gibibyte" title="Gibibyte">GB</a> virtual address space might be cut up into 1048576 pages of 4&#160;KB size, each of which can be independently mapped. There may be multiple page sizes supported; see <a href="/wiki/Virtual_memory" title="Virtual memory">virtual memory</a> for elaboration.</li>
</ul>
<p>A historical note: some early virtual memory systems were very slow, because they required an access to the page table (held in main memory) before every programmed access to main memory.<sup id="cite_ref-15" class="reference"><a href="#cite_note-15"><span>[</span>NB 1<span>]</span></a></sup> With no caches, this effectively cut the speed of the machine in half. The first hardware cache used in a computer system was not actually a data or instruction cache, but rather a TLB.</p>
<p>Caches can be divided into 4 types, based on whether the index or tag correspond to physical or virtual addresses:</p>
<ul>
<li><i>Physically indexed, physically tagged</i> (PIPT) caches use the physical address for both the index and the tag. While this is simple and avoids problems with aliasing, it is also slow, as the physical address must be looked up (which could involve a TLB miss and access to main memory) before that address can be looked up in the cache.</li>
</ul>
<ul>
<li><i>Virtually indexed, virtually tagged</i> (VIVT) caches use the virtual address for both the index and the tag. This caching scheme can result in much faster lookups, since the MMU does not need to be consulted first to determine the physical address for a given virtual address. However, VIVT suffers from aliasing problems, where several different virtual addresses may refer to the same physical address. The result is that such addresses would be cached separately despite referring to the same memory, causing coherency problems. Another problem is homonyms, where the same virtual address maps to several different physical addresses. It is not possible to distinguish these mappings by only looking at the virtual index, though potential solutions include: flushing the cache after a <a href="/wiki/Context_switch" title="Context switch">context switch</a>, forcing address spaces to be non-overlapping, tagging the virtual address with an address space ID (ASID), or using physical tags. Additionally, there is a problem that virtual-to-physical mappings can change, which would require flushing cache lines, as the VAs would no longer be valid.</li>
</ul>
<ul>
<li><i>Virtually indexed, physically tagged</i> (VIPT) caches use the virtual address for the index and the physical address in the tag. The advantage over PIPT is lower latency, as the cache line can be looked up in parallel with the TLB translation, however the tag cannot be compared until the physical address is available. The advantage over VIVT is that since the tag has the physical address, the cache can detect homonyms. VIPT requires more tag bits, as the index bits no longer represent the same address.</li>
</ul>
<ul>
<li><i>Physically indexed, virtually tagged</i> (PIVT) caches are only theoretical as they would basically be useless. A cache with this structure would be just as slow as PIPT, suffering from aliasing problems at the same time like VIVT.<sup id="cite_ref-16" class="reference"><a href="#cite_note-16"><span>[</span>15<span>]</span></a></sup></li>
</ul>
<p>The speed of this recurrence (the <i>load latency</i>) is crucial to CPU performance, and so most modern level-1 caches are virtually indexed, which at least allows the MMU's TLB lookup to proceed in parallel with fetching the data from the cache RAM.</p>
<p>But virtual indexing is not the best choice for all cache levels. The cost of dealing with virtual aliases grows with cache size, and as a result most level-2 and larger caches are physically indexed.</p>
<p>Caches have historically used both virtual and physical addresses for the cache tags, although virtual tagging is now uncommon. If the TLB lookup can finish before the cache RAM lookup, then the physical address is available in time for tag compare, and there is no need for virtual tagging. Large caches, then, tend to be physically tagged, and only small, very low latency caches are virtually tagged. In recent general-purpose CPUs, virtual tagging has been superseded by vhints, as described below.</p>
<h3><span class="mw-headline" id="Homonym_and_synonym_problems">Homonym and synonym problems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=18" title="Edit section: Homonym and synonym problems">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The cache that relies on the virtual indexing and tagging becomes inconsistent after the same virtual address is mapped into different physical addresses (<a href="/wiki/Homonym" title="Homonym">homonym</a>). This can be solved by using physical address for tagging or by storing the address space id in the cache line. However the latter of these two approaches does not help against the <a href="/wiki/Synonym" title="Synonym">synonym</a> problem, where several cache lines end up storing data for the same physical address. Writing to such location may update only one location in the cache, leaving others with inconsistent data. This problem might be solved by using non overlapping memory layouts for different address spaces or otherwise the cache (or part of it) must be flushed when the mapping changes.<sup id="cite_ref-17" class="reference"><a href="#cite_note-17"><span>[</span>16<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Virtual_tags_and_vhints">Virtual tags and vhints</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=19" title="Edit section: Virtual tags and vhints">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The great advantage of virtual tags is that, for associative caches, they allow the tag match to proceed before the virtual to physical translation is done. However,</p>
<ul>
<li>coherence probes and evictions present a physical address for action. The hardware must have some means of converting the physical addresses into a cache index, generally by storing physical tags as well as virtual tags. For comparison, a physically tagged cache does not need to keep virtual tags, which is simpler.</li>
</ul>
<ul>
<li>When a virtual to physical mapping is deleted from the TLB, cache entries with those virtual addresses will have to be flushed somehow. Alternatively, if cache entries are allowed on pages not mapped by the TLB, then those entries will have to be flushed when the access rights on those pages are changed in the page table.</li>
</ul>
<p>It is also possible for the operating system to ensure that no virtual aliases are simultaneously resident in the cache. The operating system makes this guarantee by enforcing page coloring, which is described below. Some early RISC processors (SPARC, RS/6000) took this approach. It has not been used recently, as the hardware cost of detecting and evicting virtual aliases has fallen and the software complexity and performance penalty of perfect page coloring has risen.</p>
<p>It can be useful to distinguish the two functions of tags in an associative cache: they are used to determine which way of the entry set to select, and they are used to determine if the cache hit or missed. The second function must always be correct, but it is permissible for the first function to guess, and get the wrong answer occasionally.</p>
<p>Some processors (e.g. early SPARCs) have caches with both virtual and physical tags. The virtual tags are used for way selection, and the physical tags are used for determining hit or miss. This kind of cache enjoys the latency advantage of a virtually tagged cache, and the simple software interface of a physically tagged cache. It bears the added cost of duplicated tags, however. Also, during miss processing, the alternate ways of the cache line indexed have to be probed for virtual aliases and any matches evicted.</p>
<p>The extra area (and some latency) can be mitigated by keeping <i>virtual hints</i> with each cache entry instead of virtual tags. These hints are a subset or hash of the virtual tag, and are used for selecting the way of the cache from which to get data and a physical tag. Like a virtually tagged cache, there may be a virtual hint match but physical tag mismatch, in which case the cache entry with the matching hint must be evicted so that cache accesses after the cache fill at this address will have just one hint match. Since virtual hints have fewer bits than virtual tags distinguishing them from one another, a virtually hinted cache suffers more conflict misses than a virtually tagged cache.</p>
<p>Perhaps the ultimate reduction of virtual hints can be found in the Pentium 4 (Willamette and Northwood cores). In these processors the virtual hint is effectively 2 bits, and the cache is 4-way set associative. Effectively, the hardware maintains a simple permutation from virtual address to cache index, so that no <a href="/wiki/Content-addressable_memory" title="Content-addressable memory">content-addressable memory</a> (CAM) is necessary to select the right one of the four ways fetched.</p>
<h3><span class="mw-headline" id="Page_coloring">Page coloring</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=20" title="Edit section: Page coloring">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div class="hatnote relarticle mainarticle">Main article: <a href="/wiki/Cache_coloring" title="Cache coloring">Cache coloring</a></div>
<p>Large physically indexed caches (usually secondary caches) run into a problem: the operating system rather than the application controls which pages collide with one another in the cache. Differences in page allocation from one program run to the next lead to differences in the cache collision patterns, which can lead to very large differences in program performance. These differences can make it very difficult to get a consistent and repeatable timing for a benchmark run.</p>
<p>To understand the problem, consider a CPU with a 1&#160;MB physically indexed direct-mapped level-2 cache and 4&#160;KB virtual memory pages. Sequential physical pages map to sequential locations in the cache until after 256 pages the pattern wraps around. We can label each physical page with a color of 0–255 to denote where in the cache it can go. Locations within physical pages with different colors cannot conflict in the cache.</p>
<p>Programmers attempting to make maximum use of the cache may arrange their programs' access patterns so that only 1&#160;MB of data need be cached at any given time, thus avoiding capacity misses. But they should also ensure that the access patterns do not have conflict misses. One way to think about this problem is to divide up the virtual pages the program uses and assign them virtual colors in the same way as physical colors were assigned to physical pages before. Programmers can then arrange the access patterns of their code so that no two pages with the same virtual color are in use at the same time. There is a wide literature on such optimizations (e.g. <a href="/wiki/Loop_nest_optimization" title="Loop nest optimization">loop nest optimization</a>), largely coming from the <a href="/wiki/High_Performance_Computing" title="High Performance Computing" class="mw-redirect">High Performance Computing (HPC)</a> community.</p>
<p>The snag is that while all the pages in use at any given moment may have different virtual colors, some may have the same physical colors. In fact, if the operating system assigns physical pages to virtual pages randomly and uniformly, it is extremely likely that some pages will have the same physical color, and then locations from those pages will collide in the cache (this is the <a href="/wiki/Birthday_paradox" title="Birthday paradox" class="mw-redirect">birthday paradox</a>).</p>
<p>The solution is to have the operating system attempt to assign different physical color pages to different virtual colors, a technique called <i>page coloring</i>. Although the actual mapping from virtual to physical color is irrelevant to system performance, odd mappings are difficult to keep track of and have little benefit, so most approaches to page coloring simply try to keep physical and virtual page colors the same.</p>
<p>If the operating system can guarantee that each physical page maps to only one virtual color, then there are no virtual aliases, and the processor can use virtually indexed caches with no need for extra virtual alias probes during miss handling. Alternatively, the OS can flush a page from the cache whenever it changes from one virtual color to another. As mentioned above, this approach was used for some early SPARC and RS/6000 designs.</p>
<h2><span class="mw-headline" id="Cache_hierarchy_in_a_modern_processor"><span id="Cache_hierarchy"></span> Cache hierarchy in a modern processor</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=21" title="Edit section: Cache hierarchy in a modern processor">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:302px;"><a href="/wiki/File:Hwloc.png" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hwloc.png/300px-Hwloc.png" width="300" height="139" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hwloc.png/450px-Hwloc.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hwloc.png/600px-Hwloc.png 2x" data-file-width="1450" data-file-height="670" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Hwloc.png" class="internal" title="Enlarge"></a></div>
Memory hierarchy of an AMD Bulldozer server.</div>
</div>
</div>
<p>Modern processors have multiple interacting caches on chip.</p>
<p>The operation of a particular cache can be completely specified by:<sup id="cite_ref-ccs.neu.edu_4-2" class="reference"><a href="#cite_note-ccs.neu.edu-4"><span>[</span>4<span>]</span></a></sup></p>
<ul>
<li>the cache size</li>
<li>the cache block size</li>
<li>the number of blocks in a set</li>
<li>the cache set replacement policy</li>
<li>the cache write policy (write-through or write-back)</li>
</ul>
<p>While all of the cache blocks in a particular cache are the same size and have the same associativity, typically "lower-level" caches (such as the L1 cache) have a smaller size, have smaller blocks, and have fewer blocks in a set, while "higher-level" caches (such as the L3 cache) have larger size, larger blocks, and more blocks in a set.</p>
<h3><span class="mw-headline" id="Specialized_caches">Specialized caches</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=22" title="Edit section: Specialized caches">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Pipelined CPUs access memory from multiple points in the <a href="/wiki/Instruction_pipeline" title="Instruction pipeline">pipeline</a>: instruction fetch, <a href="/wiki/Virtual_memory" title="Virtual memory">virtual-to-physical</a> address translation, and data fetch (see <a href="/wiki/Classic_RISC_pipeline" title="Classic RISC pipeline">classic RISC pipeline</a>). The natural design is to use different physical caches for each of these points, so that no one physical resource has to be scheduled to service two points in the pipeline. Thus the pipeline naturally ends up with at least three separate caches (instruction, <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">TLB</a>, and data), each specialized to its particular role.</p>
<h4><span class="mw-headline" id="Victim_cache">Victim cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=23" title="Edit section: Victim cache">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A <b>victim cache</b> is a cache used to hold blocks evicted from a CPU cache upon replacement. The victim cache lies between the main cache and its refill path, and only holds blocks that were evicted from the main cache. The victim cache is usually fully associative, and is intended to reduce the number of conflict misses. Many commonly used programs do not require an associative mapping for all the accesses. In fact, only a small fraction of the memory accesses of the program require high associativity. The victim cache exploits this property by providing high associativity to only these accesses. It was introduced by <a href="/w/index.php?title=Norman_Jouppi&amp;action=edit&amp;redlink=1" class="new" title="Norman Jouppi (page does not exist)">Norman Jouppi</a> from DEC in 1990.<sup id="cite_ref-18" class="reference"><a href="#cite_note-18"><span>[</span>17<span>]</span></a></sup></p>
<p>Intel's <i>Crystal Well</i><sup id="cite_ref-intel-ark-crystal-well_19-0" class="reference"><a href="#cite_note-intel-ark-crystal-well-19"><span>[</span>18<span>]</span></a></sup> variant of its <a href="/wiki/Haswell_(microarchitecture)" title="Haswell (microarchitecture)">Haswell</a> processors, equipped with Intel's Iris Pro GT3e embedded graphics and 128&#160;MB of <a href="/wiki/EDRAM" title="EDRAM">eDRAM</a>, introduced an on-package Level 4 cache which serves as a victim cache to the processors's Level 3 cache.<sup id="cite_ref-anandtech-i74950hq_20-0" class="reference"><a href="#cite_note-anandtech-i74950hq-20"><span>[</span>19<span>]</span></a></sup></p>
<h4><span class="mw-headline" id="Trace_cache"><span id="TRACE-CACHE"></span>Trace cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=24" title="Edit section: Trace cache">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>One of the more extreme examples of cache specialization is the <b>trace cache</b> found in the <a href="/wiki/Intel" title="Intel">Intel</a> <a href="/wiki/Pentium_4" title="Pentium 4">Pentium 4</a> microprocessors. A trace cache is a mechanism for increasing the instruction fetch bandwidth and decreasing power consumption (in the case of the Pentium 4) by storing traces of <a href="/wiki/Instruction_(computer_science)" title="Instruction (computer science)" class="mw-redirect">instructions</a> that have already been fetched and decoded.</p>
<p>The earliest widely acknowledged academic publication of trace cache was by Eric Rotenberg, Steve Bennett, and Jim Smith in their 1996 paper <i>"Trace Cache: a Low Latency Approach to High Bandwidth Instruction Fetching"</i>.<sup id="cite_ref-21" class="reference"><a href="#cite_note-21"><span>[</span>20<span>]</span></a></sup> An earlier publication is <span class="citation patent" id="CITEREFAlex_Peleg_and_Uri_Weiser_of_Intel_Corp.2015"><a rel="nofollow" class="external text" href="http://worldwide.espacenet.com/textdoc?DB=EPODOC&amp;IDX=US5381533">US patent 5381533</a>, Alex Peleg and Uri Weiser of Intel Corp., "Dynamic flow instruction cache memory organized around trace segments independent of virtual address line"</span><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Apatent&amp;rft.number=5381533&amp;rft.cc=US&amp;rft.title=Dynamic+flow+instruction+cache+memory+organized+around+trace+segments+independent+of+virtual+address+line&amp;rft.inventor=Alex+Peleg+and+Uri+Weiser+of+Intel+Corp.&amp;rft.appldate=1994-03-30"><span style="display: none;">&#160;</span></span>, a continuation of an application filed in 1992, later abandoned.</p>
<p>A trace cache stores instructions either after they have been decoded, or as they are retired. Generally, instructions are added to trace caches in groups representing either individual <a href="/wiki/Basic_block" title="Basic block">basic blocks</a> or dynamic instruction traces. A dynamic trace ("trace path") contains only instructions whose results are actually used, and eliminates instructions following taken branches (since they are not executed); a dynamic trace can be a concatenation of multiple basic blocks. This allows the instruction fetch unit of a processor to fetch several basic blocks, without having to worry about branches in the execution flow.<sup id="cite_ref-tc-slides_22-0" class="reference"><a href="#cite_note-tc-slides-22"><span>[</span>21<span>]</span></a></sup></p>
<p>Trace lines are stored in the trace cache based on the <a href="/wiki/Program_counter" title="Program counter">program counter</a> of the first instruction in the trace and a set of branch predictions. This allows for storing different trace paths that start on the same address, each representing different branch outcomes. In the instruction fetch stage of a <a href="/wiki/Instruction_pipeline" title="Instruction pipeline">pipeline</a>, the current program counter along with a set of branch predictions is checked in the trace cache for a hit. If there is a hit, a trace line is supplied to fetch which does not have to go to a regular cache or to memory for these instructions. The trace cache continues to feed the fetch unit until the trace line ends or until there is a <a href="/wiki/Misprediction" title="Misprediction" class="mw-redirect">misprediction</a> in the pipeline. If there is a miss, a new trace starts to be built.</p>
<p>The Pentium 4's trace cache stores <a href="/wiki/Micro-operations" title="Micro-operations" class="mw-redirect">micro-operations</a> resulting from decoding x86 instructions, providing also the functionality of a micro-operation cache. Having this, the next time an instruction is needed, it does not have to be decoded into micro-ops again.<sup id="cite_ref-agner.org_23-0" class="reference"><a href="#cite_note-agner.org-23"><span>[</span>22<span>]</span></a></sup><sup class="reference" style="white-space:nowrap;">:63–68</sup></p>
<h4><span class="mw-headline" id="Micro-operation_.28uop.29_cache"><span id="UOP-CACHE"></span>Micro-operation (uop) cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=25" title="Edit section: Micro-operation (uop) cache">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A <b>micro-operation cache</b> (<b>Uop Cache</b>, <b>UC</b>) is a specialized cache that stores <a href="/wiki/Micro-operation" title="Micro-operation">micro-operations</a> of decoded instructions, as received directly from the <a href="/wiki/Instruction_decoder" title="Instruction decoder" class="mw-redirect">instruction decoders</a> or from the instruction cache. When an instruction needs to be decoded, the uop cache is checked for its decoded form which is re-used if cached; if it is not available, the instruction is decoded and then cached.</p>
<p>One of the early works describing uop cache as an alternative frontend for the Intel <a href="/wiki/P6_(microarchitecture)" title="P6 (microarchitecture)">P6 processor family</a>, is the 2001 paper <i>"Micro-Operation Cache: A Power Aware Frontend for Variable Instruction Length ISA"</i>.<sup id="cite_ref-uop-intel_24-0" class="reference"><a href="#cite_note-uop-intel-24"><span>[</span>23<span>]</span></a></sup> Later, Intel included uop caches in its <a href="/wiki/Sandy_Bridge" title="Sandy Bridge">Sandy Bridge</a> processors and in successive microarchitectures like <a href="/wiki/Ivy_Bridge_(microarchitecture)" title="Ivy Bridge (microarchitecture)">Ivy Bridge</a> and <a href="/wiki/Haswell_(microarchitecture)" title="Haswell (microarchitecture)">Haswell</a>.<sup id="cite_ref-agner.org_23-1" class="reference"><a href="#cite_note-agner.org-23"><span>[</span>22<span>]</span></a></sup><sup class="reference" style="white-space:nowrap;">:121–123</sup><sup id="cite_ref-anandtech-haswell_25-0" class="reference"><a href="#cite_note-anandtech-haswell-25"><span>[</span>24<span>]</span></a></sup></p>
<p>Fetching complete pre-decoded instructions eliminates the need to repeatedly decode variable length complex instructions into simpler fixed-length micro-operations, and simplifies the process of predicting, fetching, rotating and aligning fetched instructions. A uop cache effectively offloads the fetch and decode hardware, thus decreasing <a href="/wiki/Power_consumption" title="Power consumption" class="mw-redirect">power consumption</a> and improving the frontend supply of decoded micro-operations. The uop cache also increases performance by more consistently delivering decoded micro-operations to the backend and eliminating various bottlenecks in the CPU's fetch and decode logic.<sup id="cite_ref-uop-intel_24-1" class="reference"><a href="#cite_note-uop-intel-24"><span>[</span>23<span>]</span></a></sup><sup id="cite_ref-anandtech-haswell_25-1" class="reference"><a href="#cite_note-anandtech-haswell-25"><span>[</span>24<span>]</span></a></sup></p>
<p>A uop cache has many similarities with a trace cache, although a uop cache is much simpler thus providing better power efficiency; this makes it better suited for implementations on battery-powered devices. The main disadvantage of the trace cache, leading to its power inefficiency, is the hardware complexity required for its <a href="/wiki/Heuristic" title="Heuristic">heuristic</a> deciding on caching and reusing dynamically created instruction traces.<sup id="cite_ref-tc-slides_22-1" class="reference"><a href="#cite_note-tc-slides-22"><span>[</span>21<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Multi-level_caches"><span id="MULTILEVEL"></span>Multi-level caches</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=26" title="Edit section: Multi-level caches">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Another issue is the fundamental tradeoff between cache latency and hit rate. Larger caches have better hit rates but longer latency. To address this tradeoff, many computers use multiple levels of cache, with small fast caches backed up by larger, slower caches. Multi-level caches generally operate by checking the fastest, <i>level 1</i> (L1) cache first; if it hits, the processor proceeds at high speed. If that smaller cache misses, the next fastest cache (<i>level 2</i>, L2) is checked, and so on, before external memory is checked.</p>
<p>As the latency difference between main memory and the fastest cache has become larger, some processors have begun to utilize as many as three levels of on-chip cache. Price-sensitive designs used this to pull the entire cache hierarchy on-chip, but by the 2010s some of the highest-performance designs returned to having large off-chip caches—often implemented in <a href="/wiki/EDRAM" title="EDRAM">eDRAM</a> and mounted on a <a href="/wiki/Multi-chip_module" title="Multi-chip module">multi-chip module</a>—as a fourth cache level.</p>
<p>For example, the <a href="/wiki/Alpha_21164" title="Alpha 21164">Alpha 21164</a> (1995) had 1 to 64&#160;MB off-chip L3 cache; the IBM <a href="/wiki/POWER4" title="POWER4">POWER4</a> (2001) had off-chip L3 caches of 32&#160;MB per processor, shared among several processors; the <a href="/wiki/Itanium_2" title="Itanium 2" class="mw-redirect">Itanium 2</a> (2003) had a 6&#160;MB <a href="/w/index.php?title=Unified_cache&amp;action=edit&amp;redlink=1" class="new" title="Unified cache (page does not exist)">unified</a> level 3 (L3) cache on-die; the <a href="/wiki/Itanium_2" title="Itanium 2" class="mw-redirect">Itanium 2</a> (2003) MX 2 Module incorporates two Itanium2 processors along with a shared 64&#160;MB L4 cache on a <a href="/wiki/Multi-chip_module" title="Multi-chip module">Multi-chip module</a> that was pin compatible with a Madison processor; Intel's <a href="/wiki/Xeon" title="Xeon">Xeon</a> MP product code-named "Tulsa" (2006) features 16&#160;MB of on-die L3 cache shared between two processor cores; the AMD <a href="/wiki/Phenom_II" title="Phenom II">Phenom II</a> (2008) has up to 6&#160;MB on-die unified L3 cache; the <a href="/wiki/Intel_Core_i7" title="Intel Core i7" class="mw-redirect">Intel Core i7</a> (2008) has an 8&#160;MB on-die unified L3 cache that is inclusive, shared by all cores; Intel <a href="/wiki/Haswell_(microarchitecture)" title="Haswell (microarchitecture)">Haswell</a> CPUs with integrated <a href="/wiki/Intel_Iris_Pro_Graphics" title="Intel Iris Pro Graphics" class="mw-redirect">Intel Iris Pro Graphics</a> have 128&#160;MB of eDRAM acting essentially as an L4 cache.<sup id="cite_ref-26" class="reference"><a href="#cite_note-26"><span>[</span>25<span>]</span></a></sup> The benefits of an L3 cache depend on the application's access patterns.</p>
<p>Finally, at the other end of the memory hierarchy, the CPU <a href="/wiki/Register_file" title="Register file">register file</a> itself can be considered the smallest, fastest cache in the system, with the special characteristic that it is scheduled in software—typically by a compiler, as it allocates registers to hold values retrieved from main memory. (See especially <a href="/wiki/Loop_nest_optimization" title="Loop nest optimization">loop nest optimization</a>.) Register files sometimes also have hierarchy: The <a href="/wiki/Cray-1" title="Cray-1">Cray-1</a> (circa 1976) had eight address "A" and eight scalar data "S" registers that were generally usable. There was also a set of 64 address "B" and 64 scalar data "T" registers that took longer to access, but were faster than main memory. The "B" and "T" registers were provided because the Cray-1 did not have a data cache. (The Cray-1 did, however, have an instruction cache.)</p>
<h4><span class="mw-headline" id="Multi-core_chips"><span id="LLC"></span>Multi-core chips</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=27" title="Edit section: Multi-core chips">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>When considering a chip with multiple cores, there is a question of whether the caches should be shared or local to each core. Implementing shared cache undoubtedly introduces more wiring and complexity. But then, having one cache per <i>chip</i>, rather than <i>core</i>, greatly reduces the amount of space needed, and thus one can include a larger cache.</p>
<p>Typically, sharing the L1 cache is undesirable since the latency increase is such that each core will run considerably slower than a single-core chip. On the other side, for the highest level (the last one called before accessing memory), having a global cache is desirable for several reasons. For example, an eight-core chip with three levels may include an L1 cache for each core, one intermediate L2 cache for each pair of cores, and one L3 cache shared by all cores.</p>
<p>Shared highest-level cache, which is called before accessing memory, is usually referred to as the <i>last level cache</i> (LLC). Additional techniques are used for increasing the level of parallelism when LLC is shared between multiple cores, including slicing it into multiple pieces which are addressing certain ranges of memory addresses, and can be accessed independently.<sup id="cite_ref-27" class="reference"><a href="#cite_note-27"><span>[</span>26<span>]</span></a></sup></p>
<h4><span class="mw-headline" id="Separate_versus_unified">Separate versus unified</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=28" title="Edit section: Separate versus unified">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In a separate cache structure, instructions and data are cached separately, meaning that a cache line is used to cache either instructions or data, but not both; various benefits have been demonstrated with separate data and instruction <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">translation lookaside buffers</a>.<sup id="cite_ref-28" class="reference"><a href="#cite_note-28"><span>[</span>27<span>]</span></a></sup> In a unified structure, this constraint is not present, and cache lines can be used to cache both instructions and data.</p>
<h4><span class="mw-headline" id="Exclusive_versus_inclusive"><span id="INCLUSIVE"></span><span id="EXCLUSIVE"></span>Exclusive versus inclusive</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=29" title="Edit section: Exclusive versus inclusive">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Multi-level caches introduce new design decisions. For instance, in some processors, all data in the L1 cache must also be somewhere in the L2 cache. These caches are called <i>strictly inclusive</i>. Other processors (like the AMD Athlon) have <i>exclusive</i> caches: data is guaranteed to be in at most one of the L1 and L2 caches, never in both. Still other processors (like the Intel <a href="/wiki/Pentium_II" title="Pentium II">Pentium II</a>, <a href="/wiki/Pentium_III" title="Pentium III">III</a>, and <a href="/wiki/Pentium_4" title="Pentium 4">4</a>), do not require that data in the L1 cache also reside in the L2 cache, although it may often do so. There is no universally accepted name for this intermediate policy.<sup id="cite_ref-29" class="reference"><a href="#cite_note-29"><span>[</span>28<span>]</span></a></sup><sup id="cite_ref-ispass04_30-0" class="reference"><a href="#cite_note-ispass04-30"><span>[</span>29<span>]</span></a></sup></p>
<p>The advantage of exclusive caches is that they store more data. This advantage is larger when the exclusive L1 cache is comparable to the L2 cache, and diminishes if the L2 cache is many times larger than the L1 cache. When the L1 misses and the L2 hits on an access, the hitting cache line in the L2 is exchanged with a line in the L1. This exchange is quite a bit more work than just copying a line from L2 to L1, which is what an inclusive cache does.<sup id="cite_ref-ispass04_30-1" class="reference"><a href="#cite_note-ispass04-30"><span>[</span>29<span>]</span></a></sup></p>
<p>One advantage of strictly inclusive caches is that when external devices or other processors in a multiprocessor system wish to remove a cache line from the processor, they need only have the processor check the L2 cache. In cache hierarchies which do not enforce inclusion, the L1 cache must be checked as well. As a drawback, there is a correlation between the associativities of L1 and L2 caches: if the L2 cache does not have at least as many ways as all L1 caches together, the effective associativity of the L1 caches is restricted. Another disadvantage of inclusive cache is that whenever there is an eviction in L2 cache, the (possibly) corresponding lines in L1 also have to get evicted in order to maintain inclusiveness. This is quite a bit work, and would result in higher L1 miss rate.<sup id="cite_ref-ispass04_30-2" class="reference"><a href="#cite_note-ispass04-30"><span>[</span>29<span>]</span></a></sup></p>
<p>Another advantage of inclusive caches is that the larger cache can use larger cache lines, which reduces the size of the secondary cache tags. (Exclusive caches require both caches to have the same size cache lines, so that cache lines can be swapped on a L1 miss, L2 hit.) If the secondary cache is an order of magnitude larger than the primary, and the cache data is an order of magnitude larger than the cache tags, this tag area saved can be comparable to the incremental area needed to store the L1 cache data in the L2.<sup id="cite_ref-31" class="reference"><a href="#cite_note-31"><span>[</span>30<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Example:_the_K8">Example: the K8</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=30" title="Edit section: Example: the K8">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>To illustrate both specialization and multi-level caching, here is the cache hierarchy of the K8 core in the AMD <a href="/wiki/Athlon_64" title="Athlon 64">Athlon 64</a> CPU.<sup id="cite_ref-32" class="reference"><a href="#cite_note-32"><span>[</span>31<span>]</span></a></sup></p>
<div class="center">
<div class="thumb tnone">
<div class="thumbinner" style="width:502px;"><a href="/wiki/File:Cache,hierarchy-example.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/1/11/Cache%2Chierarchy-example.svg/500px-Cache%2Chierarchy-example.svg.png" width="500" height="333" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/1/11/Cache%2Chierarchy-example.svg/750px-Cache%2Chierarchy-example.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/1/11/Cache%2Chierarchy-example.svg/1000px-Cache%2Chierarchy-example.svg.png 2x" data-file-width="600" data-file-height="400" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Cache,hierarchy-example.svg" class="internal" title="Enlarge"></a></div>
Cache hierarchy of the K8 core in the AMD Athlon 64 CPU.</div>
</div>
</div>
</div>
<p>The K8 has four specialized caches: an instruction cache, an instruction <a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">TLB</a>, a data TLB, and a data cache. Each of these caches is specialized:</p>
<ul>
<li>The instruction cache keeps copies of 64-byte lines of memory, and fetches 16 bytes each cycle. Each byte in this cache is stored in ten bits rather than eight, with the extra bits marking the boundaries of instructions (this is an example of predecoding). The cache has only <a href="/wiki/Parity_bit" title="Parity bit">parity</a> protection rather than <a href="/wiki/Error-correcting_code" title="Error-correcting code" class="mw-redirect">ECC</a>, because parity is smaller and any damaged data can be replaced by fresh data fetched from memory (which always has an up-to-date copy of instructions).</li>
</ul>
<ul>
<li>The instruction TLB keeps copies of page table entries (PTEs). Each cycle's instruction fetch has its virtual address translated through this TLB into a physical address. Each entry is either four or eight bytes in memory. Because the K8 has a variable page size, each of the TLBs is split into two sections, one to keep PTEs that map 4&#160;KB pages, and one to keep PTEs that map 4&#160;MB or 2&#160;MB pages. The split allows the fully associative match circuitry in each section to be simpler. The operating system maps different sections of the virtual address space with different size PTEs.</li>
</ul>
<ul>
<li>The data TLB has two copies which keep identical entries. The two copies allow two data accesses per cycle to translate virtual addresses to physical addresses. Like the instruction TLB, this TLB is split into two kinds of entries.</li>
</ul>
<ul>
<li>The data cache keeps copies of 64-byte lines of memory. It is split into 8 banks (each storing 8&#160;KB of data), and can fetch two 8-byte data each cycle so long as those data are in different banks. There are two copies of the tags, because each 64-byte line is spread among all eight banks. Each tag copy handles one of the two accesses per cycle.</li>
</ul>
<p>The K8 also has multiple-level caches. There are second-level instruction and data TLBs, which store only PTEs mapping 4&#160;KB. Both instruction and data caches, and the various TLBs, can fill from the large <b>unified</b> L2 cache. This cache is exclusive to both the L1 instruction and data caches, which means that any 8-byte line can only be in one of the L1 instruction cache, the L1 data cache, or the L2 cache. It is, however, possible for a line in the data cache to have a PTE which is also in one of the TLBs—the operating system is responsible for keeping the TLBs coherent by flushing portions of them when the page tables in memory are updated.</p>
<p>The K8 also caches information that is never stored in memory—prediction information. These caches are not shown in the above diagram. As is usual for this class of CPU, the K8 has fairly complex <a href="/wiki/Branch_prediction" title="Branch prediction" class="mw-redirect">branch prediction</a>, with tables that help predict whether branches are taken and other tables which predict the targets of branches and jumps. Some of this information is associated with instructions, in both the level 1 instruction cache and the unified secondary cache.</p>
<p>The K8 uses an interesting trick to store prediction information with instructions in the secondary cache. Lines in the secondary cache are protected from accidental data corruption (e.g. by an <a href="/wiki/Alpha_particle" title="Alpha particle">alpha particle</a> strike) by either <a href="/wiki/Error-correcting_code" title="Error-correcting code" class="mw-redirect">ECC</a> or <a href="/wiki/Parity_(telecommunication)" title="Parity (telecommunication)" class="mw-redirect">parity</a>, depending on whether those lines were evicted from the data or instruction primary caches. Since the parity code takes fewer bits than the ECC code, lines from the instruction cache have a few spare bits. These bits are used to cache branch prediction information associated with those instructions. The net result is that the branch predictor has a larger effective history table, and so has better accuracy.</p>
<h3><span class="mw-headline" id="More_hierarchies">More hierarchies</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=31" title="Edit section: More hierarchies">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Other processors have other kinds of predictors (e.g. the store-to-load bypass predictor in the <a href="/wiki/Digital_Equipment_Corporation" title="Digital Equipment Corporation">DEC</a> <a href="/wiki/Alpha_21264" title="Alpha 21264">Alpha 21264</a>), and various specialized predictors are likely to flourish in future processors.</p>
<p>These predictors are caches in that they store information that is costly to compute. Some of the terminology used when discussing predictors is the same as that for caches (one speaks of a <b>hit</b> in a branch predictor), but predictors are not generally thought of as part of the cache hierarchy.</p>
<p>The K8 keeps the instruction and data caches <b><a href="/wiki/Cache_coherency" title="Cache coherency" class="mw-redirect">coherent</a></b> in hardware, which means that a store into an instruction closely following the store instruction will change that following instruction. Other processors, like those in the Alpha and MIPS family, have relied on software to keep the instruction cache coherent. Stores are not guaranteed to show up in the instruction stream until a program calls an operating system facility to ensure coherency.</p>
<h2><span class="mw-headline" id="Implementation">Implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=32" title="Edit section: Implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="hatnote relarticle mainarticle">Main article: <a href="/wiki/Cache_algorithms" title="Cache algorithms">Cache algorithms</a></div>
<p>Cache <b>reads</b> are the most common CPU operation that takes more than a single cycle. Program execution time tends to be very sensitive to the latency of a level-1 data cache hit. A great deal of design effort, and often power and silicon area are expended making the caches as fast as possible.</p>
<p>The simplest cache is a virtually indexed direct-mapped cache. The virtual address is calculated with an adder, the relevant portion of the address extracted and used to index an SRAM, which returns the loaded data. The data is byte aligned in a byte shifter, and from there is bypassed to the next operation. There is no need for any tag checking in the inner loop — in fact, the tags need not even be read. Later in the pipeline, but before the load instruction is retired, the tag for the loaded data must be read, and checked against the virtual address to make sure there was a cache hit. On a miss, the cache is updated with the requested cache line and the pipeline is restarted.</p>
<p>An associative cache is more complicated, because some form of tag must be read to determine which entry of the cache to select. An N-way set-associative level-1 cache usually reads all N possible tags and N data in parallel, and then chooses the data associated with the matching tag. Level-2 caches sometimes save power by reading the tags first, so that only one data element is read from the data SRAM.</p>
<div class="thumb tright">
<div class="thumbinner" style="width:402px;"><a href="/wiki/File:Cache,associative-read.svg" class="image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Cache%2Cassociative-read.svg/400px-Cache%2Cassociative-read.svg.png" width="400" height="285" class="thumbimage" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Cache%2Cassociative-read.svg/600px-Cache%2Cassociative-read.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Cache%2Cassociative-read.svg/800px-Cache%2Cassociative-read.svg.png 2x" data-file-width="744" data-file-height="531" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Cache,associative-read.svg" class="internal" title="Enlarge"></a></div>
Read path for a 2-way associative cache</div>
</div>
</div>
<p>The diagram to the right is intended to clarify the manner in which the various fields of the address are used. Address bit 31 is most significant, bit 0 is least significant. The diagram shows the SRAMs, indexing, and multiplexing for a 4&#160;KB, 2-way set-associative, virtually indexed and virtually tagged cache with 64&#160;byte (B) lines, a 32-bit read width and 32-bit virtual address.</p>
<p>Because the cache is 4&#160;KB and has 64&#160;B lines, there are just 64 lines in the cache, and we read two at a time from a Tag SRAM which has 32 rows, each with a pair of 21 bit tags. Although any function of virtual address bits 31 through 6 could be used to index the tag and data SRAMs, it is simplest to use the least significant bits.</p>
<p>Similarly, because the cache is 4&#160;KB and has a 4&#160;B read path, and reads two ways for each access, the Data SRAM is 512 rows by 8 bytes wide.</p>
<p>A more modern cache might be 16&#160;KB, 4-way set-associative, virtually indexed, virtually hinted, and physically tagged, with 32&#160;B lines, 32-bit read width and 36-bit physical addresses. The read path recurrence for such a cache looks very similar to the path above. Instead of tags, vhints are read, and matched against a subset of the virtual address. Later on in the pipeline, the virtual address is translated into a physical address by the TLB, and the physical tag is read (just one, as the vhint supplies which way of the cache to read). Finally the physical address is compared to the physical tag to determine if a hit has occurred.</p>
<p>Some SPARC designs have improved the speed of their L1 caches by a few gate delays by collapsing the virtual address adder into the SRAM decoders. See <a href="/wiki/Sum_addressed_decoder" title="Sum addressed decoder">Sum addressed decoder</a>.</p>
<h3><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=33" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The early history of cache technology is closely tied to the invention and use of virtual memory.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (March 2008)">citation needed</span></a></i>]</sup> Because of scarcity and cost of semi-conductors memories, early mainframe computers in the 1960s used a complex hierarchy of physical memory, mapped onto a flat virtual memory space used by programs. The memory technologies would span semi-conductor, magnetic core, drum and disc. Virtual memory seen and used by programs would be flat and caching would be used to fetch data and instructions into the fastest memory ahead of processor access. Extensive studies were done to optimize the cache sizes. Optimal values were found to depend greatly on the programming language used with Algol needing the smallest and Fortran and Cobol needing the largest cache sizes.<sup class="noprint Inline-Template" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Disputed_statement" title="Wikipedia:Disputed statement" class="mw-redirect"><span title="This claim has reliable sources with contradicting facts (December 2010)">disputed</span></a> <span class="metadata">– <a href="/wiki/Talk:CPU_cache#Talk:CPU_cache.23Dispute_sequence_of_events_for_paging" title="Talk:CPU cache">discuss</a></span></i>]</sup></p>
<p>In the early days of microcomputer technology, memory access was only slightly slower than <a href="/wiki/Processor_register" title="Processor register">register</a> access. But since the 1980s<sup id="cite_ref-33" class="reference"><a href="#cite_note-33"><span>[</span>32<span>]</span></a></sup> the performance gap between processor and memory has been growing. Microprocessors have advanced much faster than memory, especially in terms of their operating <a href="/wiki/Frequency" title="Frequency">frequency</a>, so memory became a performance <a href="/wiki/Von_Neumann_architecture#Von_Neumann_bottleneck" title="Von Neumann architecture">bottleneck</a>. While it was technically possible to have all the main memory as fast as the CPU, a more economically viable path has been taken: use plenty of low-speed memory, but also introduce a small high-speed cache memory to alleviate the performance gap. This provided an order of magnitude more capacity—for the same price—with only a slightly reduced combined performance.</p>
<h4><span class="mw-headline" id="First_TLB_implementations">First TLB implementations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=34" title="Edit section: First TLB implementations">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The first documented uses of a TLB were on the <a href="/wiki/General_Electric" title="General Electric">GE</a> <a href="/wiki/GE_645" title="GE 645" class="mw-redirect">645</a><sup id="cite_ref-34" class="reference"><a href="#cite_note-34"><span>[</span>33<span>]</span></a></sup> and the <a href="/wiki/IBM" title="IBM">IBM</a> <a href="/wiki/IBM_System/360_Model_67" title="IBM System/360 Model 67">360/67</a>,<sup id="cite_ref-35" class="reference"><a href="#cite_note-35"><span>[</span>34<span>]</span></a></sup> both of which used an associative memory as a TLB.</p>
<h4><span class="mw-headline" id="First_data_cache">First data cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=35" title="Edit section: First data cache">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The first documented use of a data cache was on the <a href="/wiki/IBM" title="IBM">IBM</a> System/360 Model 85.<sup id="cite_ref-36" class="reference"><a href="#cite_note-36"><span>[</span>35<span>]</span></a></sup></p>
<h4><span class="mw-headline" id="In_68k_microprocessors">In 68k microprocessors</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=36" title="Edit section: In 68k microprocessors">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The <a href="/wiki/68010" title="68010" class="mw-redirect">68010</a>, released in 1982, has a "loop mode" which can be considered a tiny and special-case instruction cache that accelerates loops that consist of only two instructions. The <a href="/wiki/68020" title="68020" class="mw-redirect">68020</a>, released in 1984, replaced that with a typical instruction cache of 256 bytes, being the first 68k series processor to feature true on-board cache memory.</p>
<p>The <a href="/wiki/68030" title="68030" class="mw-redirect">68030</a>, released in 1987, is basically a 68020 core with an additional 256-byte data cache, a process shrink, and added burst mode for the caches. The <a href="/wiki/Motorola_68040" title="Motorola 68040">68040</a>, released in 1990, has split instruction and data caches of four kilobytes each. The <a href="/wiki/68060" title="68060" class="mw-redirect">68060</a>, released in 1994, has the following: 8&#160;KB data cache (four-way associative), 8&#160;KB instruction cache (four-way associative), 96-byte FIFO instruction buffer, 256-entry branch cache, and 64-entry address translation cache MMU buffer (four-way associative).</p>
<h4><span class="mw-headline" id="In_x86_microprocessors">In x86 microprocessors</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=37" title="Edit section: In x86 microprocessors">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>As the <a href="/wiki/X86" title="X86">x86</a> microprocessors reached clock rates of 20&#160;MHz and above in the <a href="/wiki/Intel_80386" title="Intel 80386">386</a>, small amounts of fast cache memory began to be featured in systems to improve performance. This was because the <a href="/wiki/DRAM" title="DRAM" class="mw-redirect">DRAM</a> used for main memory had significant latency, up to 120&#160;ns, as well as refresh cycles. The cache was constructed from more expensive, but significantly faster, <a href="/wiki/Static_random_access_memory" title="Static random access memory" class="mw-redirect">SRAM</a> <a href="/wiki/Memory_cell_(binary)" title="Memory cell (binary)">memory cells</a>, which at the time had latencies around 10&#160;ns. The early caches were external to the processor and typically located on the motherboard in the form of eight or nine <a href="/wiki/Dual_in-line_package" title="Dual in-line package">DIP</a> devices placed in sockets to enable the cache as an optional extra or upgrade feature.</p>
<p>Some versions of the Intel 386 processor could support 16 to 64&#160;KB of external cache.</p>
<p>With the <a href="/wiki/Intel_80486" title="Intel 80486">486</a> processor, an 8&#160;KB cache was integrated directly into the CPU die. This cache was termed Level 1 or L1 cache to differentiate it from the slower on-motherboard, or Level 2 (L2) cache. These on-motherboard caches were much larger, with the most common size being 256&#160;KB. The popularity of on-motherboard cache continued through the <a href="/wiki/Intel_P5" title="Intel P5" class="mw-redirect">Pentium MMX</a> era but was made obsolete by the introduction of <a href="/wiki/SDRAM" title="SDRAM" class="mw-redirect">SDRAM</a> and the growing disparity between bus clock rates and CPU clock rates, which caused on-motherboard cache to be only slightly faster than main memory.</p>
<p>The next development in cache implementation in the x86 microprocessors began with the <a href="/wiki/Pentium_Pro" title="Pentium Pro">Pentium Pro</a>, which brought the secondary cache onto the same package as the microprocessor, clocked at the same frequency as the microprocessor.</p>
<p>On-motherboard caches enjoyed prolonged popularity thanks to the <a href="/wiki/AMD_K6-2" title="AMD K6-2">AMD K6-2</a> and <a href="/wiki/AMD_K6-III" title="AMD K6-III">AMD K6-III</a> processors that still used the venerable <a href="/wiki/Socket_7" title="Socket 7">Socket 7</a>, which was previously used by Intel with on-motherboard caches. K6-III included 256&#160;KB on-die L2 cache and took advantage of the on-board cache as a third level cache, named L3 (motherboards with up to 2&#160;MB of on-board cache were produced). After the Socket&#160;7 became obsolete, on-motherboard cache disappeared from the x86 systems.</p>
<p>The three-level caches were used again first with the introduction of multiple processor cores, where the L3 cache was added to the CPU die. It became common for the total cache sizes to be increasingly larger in newer processor generations, and recently (as of 2011) it is not uncommon to find Level 3 cache sizes of tens of megabytes.<sup id="cite_ref-37" class="reference"><a href="#cite_note-37"><span>[</span>36<span>]</span></a></sup> This trend appears to continue for the foreseeable future.</p>
<p><a href="/wiki/Intel" title="Intel">Intel</a> introduced a Level 4 on-package cache with the <a href="/wiki/Haswell_(microarchitecture)" title="Haswell (microarchitecture)">Haswell</a> <a href="/wiki/Microarchitecture" title="Microarchitecture">microarchitecture</a>. <i>Crystal Well</i><sup id="cite_ref-intel-ark-crystal-well_19-1" class="reference"><a href="#cite_note-intel-ark-crystal-well-19"><span>[</span>18<span>]</span></a></sup> Haswell CPUs, equipped with the GT3e variant of Intel's integrated Iris Pro graphics, effectively feature 128&#160;MB of embedded DRAM (<a href="/wiki/EDRAM" title="EDRAM">eDRAM</a>) on the same package. This L4 cache is shared dynamically between the on-die GPU and CPU, and serves as a victim cache to the CPU's L3 cache.<sup id="cite_ref-anandtech-i74950hq_20-1" class="reference"><a href="#cite_note-anandtech-i74950hq-20"><span>[</span>19<span>]</span></a></sup></p>
<h4><span class="mw-headline" id="Current_research">Current research</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=38" title="Edit section: Current research">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Early cache designs focused entirely on the direct cost of cache and RAM and average execution speed. More recent cache designs also consider <a href="/wiki/Low-power_electronics" title="Low-power electronics">energy efficiency</a>,<sup id="cite_ref-38" class="reference"><a href="#cite_note-38"><span>[</span>37<span>]</span></a></sup> fault tolerance, and other goals.<sup id="cite_ref-39" class="reference"><a href="#cite_note-39"><span>[</span>38<span>]</span></a></sup> Researchers have also explored use of emerging memory technologies such as <a href="/wiki/EDRAM" title="EDRAM">eDRAM</a> (embedded DRAM) and NVRAM (non-volatile RAM) for designing caches.<sup id="cite_ref-40" class="reference"><a href="#cite_note-40"><span>[</span>39<span>]</span></a></sup></p>
<p>There are several tools available to computer architects to help explore tradeoffs between cache cycle time, energy, and area. These tools include the open-source CACTI cache simulator<sup id="cite_ref-41" class="reference"><a href="#cite_note-41"><span>[</span>40<span>]</span></a></sup> and the open-source SimpleScalar instruction set simulator. Modeling of 2D and 3D <a href="/wiki/Static_random-access_memory" title="Static random-access memory">SRAM</a>, <a href="/wiki/EDRAM" title="EDRAM">eDRAM</a>, <a href="/wiki/Spin-transfer_torque" title="Spin-transfer torque">STT-RAM</a>, <a href="/wiki/Resistive_random-access_memory" title="Resistive random-access memory">ReRAM</a> and <a href="/wiki/Phase-change_memory" title="Phase-change memory">PCM</a> caches can be done using DESTINY tool.<sup id="cite_ref-42" class="reference"><a href="#cite_note-42"><span>[</span>41<span>]</span></a></sup></p>
<h3><span class="mw-headline" id="Multi-ported_cache">Multi-ported cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=39" title="Edit section: Multi-ported cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A multi-ported cache is a cache which can serve more than one request at a time. When accessing a traditional cache we normally use a single memory address, whereas in a multi-ported cache we may request N addresses at a time - where N is the number of ports that connected through the processor and the cache. The benefit of this is that a pipelined processor may access memory from different phases in its pipeline. Another benefit is that it allows the concept of super-scalar processors through different cache levels.</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=40" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="div-col columns column-width" style="-moz-column-width: 35em; -webkit-column-width: 35em; column-width: 35em;">
<ul>
<li><a href="/wiki/Cache_coherency" title="Cache coherency" class="mw-redirect">Cache coherency</a></li>
<li><a href="/wiki/Cache_algorithms" title="Cache algorithms">Cache algorithms</a></li>
<li><a href="/wiki/Dinero_(cache_simulator)" title="Dinero (cache simulator)">Dinero</a> (Cache simulator by <a href="/wiki/University_of_Wisconsin_System" title="University of Wisconsin System">University of Wisconsin System</a>)</li>
<li><a href="/wiki/Instruction_unit" title="Instruction unit">Instruction unit</a></li>
<li><a href="/wiki/Memoization" title="Memoization">Memoization</a>, briefly defined in <a href="/wiki/List_of_computer_term_etymologies" title="List of computer term etymologies">List of computer term etymologies</a></li>
<li><a href="/wiki/No-write_allocation" title="No-write allocation" class="mw-redirect">No-write allocation</a></li>
<li><a href="/wiki/Scratchpad_RAM" title="Scratchpad RAM" class="mw-redirect">Scratchpad RAM</a></li>
<li><a href="/wiki/Write_buffer" title="Write buffer">Write buffer</a></li>
</ul>
</div>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=41" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist" style="list-style-type: decimal;">
<ol class="references">
<li id="cite_note-15"><span class="mw-cite-backlink"><b><a href="#cite_ref-15">^</a></b></span> <span class="reference-text">The very first paging machine, the <a href="/wiki/Ferranti" title="Ferranti">Ferranti</a> <a href="/wiki/Atlas_Computer_(Manchester)" title="Atlas Computer (Manchester)" class="mw-redirect">Atlas</a><sup id="cite_ref-AtlasCPU_13-0" class="reference"><a href="#cite_note-AtlasCPU-13"><span>[</span>13<span>]</span></a></sup><sup id="cite_ref-AtlasSup_14-0" class="reference"><a href="#cite_note-AtlasSup-14"><span>[</span>14<span>]</span></a></sup> had no page tables in main memory; there was an associative memory with one entry for every 512 word page frame of core.</span></li>
</ol>
</div>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=42" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist columns references-column-width" style="-moz-column-width: 30em; -webkit-column-width: 30em; column-width: 30em; list-style-type: decimal;">
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Nathan N. Sadler and Daniel J. Sorin. <a rel="nofollow" class="external text" href="http://people.ee.duke.edu/~sorin/papers/iccd06_perc.pdf">"Choosing an Error Protection Scheme for a Microprocessor’s L1 Data Cache"</a>. 2006. p. 4.</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">John L. Hennessy, David A. Patterson. "Computer Architecture: A Quantitative Approach". 2011. <a href="/wiki/Special:BookSources/012383872X" class="internal mw-magiclink-isbn">ISBN 0-12-383872-X</a>, <a href="/wiki/Special:BookSources/9780123838728" class="internal mw-magiclink-isbn">ISBN 978-0-12-383872-8</a>. page B-9. <a rel="nofollow" class="external autonumber" href="http://books.google.com/books?id=v3-1hVwHnHwC&amp;pg=PA120&amp;lpg=PA120&amp;dq=Hennessey+%22block+offset%22&amp;source=bl&amp;ots=H0RmJ057vE&amp;sig=H5fFbBYAxvTyCeUv2yooeOKxnlM&amp;hl=en&amp;sa=X&amp;ei=NHrwTsPsOtHMsQK-poW-AQ&amp;ved=0CCUQ6AEwAQ#v=onepage&amp;q=%22block%20offset%22&amp;f=false">[1]</a></span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">David A. Patterson, John L. Hennessy. "Computer organization and design: the hardware/software interface". 2009. <a href="/wiki/Special:BookSources/0123744938" class="internal mw-magiclink-isbn">ISBN 0-12-374493-8</a>, <a href="/wiki/Special:BookSources/9780123744937" class="internal mw-magiclink-isbn">ISBN 978-0-12-374493-7</a> "Chapter 5: Large and Fast: Exploiting the Memory Hierarchy". p. 484. <a rel="nofollow" class="external autonumber" href="http://books.google.com/books?id=3b63x-0P3_UC&amp;pg=PA484&amp;lpg=PA484&amp;dq=Hennessey+%22block+offset%22&amp;source=bl&amp;ots=Nyek04rcQ5&amp;sig=w7tLCmRZDfyAZ5T8tG3xmfQeDAo&amp;hl=en&amp;sa=X&amp;ei=NHrwTsPsOtHMsQK-poW-AQ&amp;ved=0CCEQ6AEwAA#v=onepage&amp;q=Hennessey%20%22block%20offset%22&amp;f=false">[2]</a></span></li>
<li id="cite_note-ccs.neu.edu-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-ccs.neu.edu_4-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-ccs.neu.edu_4-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-ccs.neu.edu_4-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text">Gene Cooperman. "Cache Basics". 2003. <a rel="nofollow" class="external autonumber" href="http://www.ccs.neu.edu/course/com3200/parent/NOTES/cache-basics.html">[3]</a></span></li>
<li id="cite_note-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-5">^</a></b></span> <span class="reference-text">Ben Dugan. "Concerning Caches". 2002. <a rel="nofollow" class="external autonumber" href="http://www.cs.washington.edu/education/courses/cse378/02sp/sections/section9-1.html">[4]</a></span></li>
<li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span> <span class="reference-text">Harvey G. Cragon. "Memory systems and pipelined processors". 1996. <a href="/wiki/Special:BookSources/0867204745" class="internal mw-magiclink-isbn">ISBN 0-86720-474-5</a>, <a href="/wiki/Special:BookSources/9780867204742" class="internal mw-magiclink-isbn">ISBN 978-0-86720-474-2</a>. "Chapter 4.1: Cache Addressing, Virtual or Real" p. 209 <a rel="nofollow" class="external autonumber" href="http://books.google.com/books?id=q2w3JSFD7l4C&amp;pg=PA209&amp;lpg=PA209&amp;dq=displacement+tag+cache&amp;source=bl&amp;ots=i3HOLDymZk&amp;sig=VOnTozBRVPb8BTcphIPSPvvFNSU&amp;hl=en&amp;sa=X&amp;ei=spTwTsm0KtHMsQK-poW-AQ&amp;ved=0CEkQ6AEwBQ#v=onepage&amp;q=displacement%20tag%20cache&amp;f=false">[5]</a></span></li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://cseweb.ucsd.edu/classes/fa10/cse240a/pdf/08/CSE240A-MBT-L15-Cache.ppt.pdf">"Cache design"</a> (PDF). ucsd.edu. 2010-12-02. p.&#160;10–15<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-02-24</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Cache+design&amp;rft.date=2010-12-02&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fcseweb.ucsd.edu%2Fclasses%2Ffa10%2Fcse240a%2Fpdf%2F08%2FCSE240A-MBT-L15-Cache.ppt.pdf&amp;rft.pages=10-15&amp;rft.pub=ucsd.edu&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-8"><span class="mw-cite-backlink"><b><a href="#cite_ref-8">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5234663">IEEE Xplore - Phased set associative cache design for reduced power consumption</a>. Ieeexplore.ieee.org (2009-08-11). Retrieved on 2013-07-30.</span></li>
<li id="cite_note-Seznec-9"><span class="mw-cite-backlink">^ <a href="#cite_ref-Seznec_9-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Seznec_9-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">André Seznec. <a rel="nofollow" class="external text" href="http://dl.acm.org/citation.cfm?doid=173682.165152">"A Case for Two-Way Skewed-Associative Caches"</a>. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//dx.doi.org/10.1145%2F173682.165152">10.1145/173682.165152</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2007-12-13</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Andr%C3%A9+Seznec&amp;rft.aulast=Andr%C3%A9+Seznec&amp;rft.btitle=A+Case+for+Two-Way+Skewed-Associative+Caches&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fdoid%3D173682.165152&amp;rft_id=info%3Adoi%2F10.1145%2F173682.165152&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-CK-10"><span class="mw-cite-backlink">^ <a href="#cite_ref-CK_10-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-CK_10-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.stanford.edu/class/ee282/08_handouts/L03-Cache.pdf">"Advanced Caching Techniques"</a> by C. Kozyrakis</span></li>
<li id="cite_note-11"><span class="mw-cite-backlink"><b><a href="#cite_ref-11">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://www.irisa.fr/caps/PROJECTS/Architecture/">Micro-Architecture</a> "Skewed-associative caches have ... major advantages over conventional set-associative caches."</span></li>
<li id="cite_note-12"><span class="mw-cite-backlink"><b><a href="#cite_ref-12">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.cs.wisc.edu/multifacet/misc/spec2000cache-data/">"Cache performance of SPEC CPU2000"</a>. Cs.wisc.edu<span class="reference-accessdate">. Retrieved <span class="nowrap">2010-05-02</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Cache+performance+of+SPEC+CPU2000&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.wisc.edu%2Fmultifacet%2Fmisc%2Fspec2000cache-data%2F&amp;rft.pub=Cs.wisc.edu&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-AtlasCPU-13"><span class="mw-cite-backlink"><b><a href="#cite_ref-AtlasCPU_13-0">^</a></b></span> <span class="reference-text"><span class="citation book">Sumner, F. H.; Haley, G.; Chenh, E. C. Y. (1962). "The Central Control Unit of the 'Atlas' Computer". <i>Information Processing 1962</i>. IFIP Congress Proceedings. Proceedings of IFIP Congress 62. Spartan.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.atitle=The+Central+Control+Unit+of+the+%27Atlas%27+Computer&amp;rft.au=Chenh%2C+E.+C.+Y.&amp;rft.aufirst=F.+H.&amp;rft.au=Haley%2C+G.&amp;rft.aulast=Sumner&amp;rft.au=Sumner%2C+F.+H.&amp;rft.btitle=Information+Processing+1962&amp;rft.date=1962&amp;rft.genre=bookitem&amp;rft.pub=Spartan&amp;rft.series=IFIP+Congress+Proceedings&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=Proceedings+of+IFIP+Congress+62" class="Z3988"><span style="display:none;">&#160;</span></span> <span style="display:none;font-size:100%" class="error citation-comment">Cite uses deprecated parameter <code style="color:inherit; border:inherit; padding:inherit;">|separator=</code> (<a href="/wiki/Help:CS1_errors#deprecated_params" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-AtlasSup-14"><span class="mw-cite-backlink"><b><a href="#cite_ref-AtlasSup_14-0">^</a></b></span> <span class="reference-text"><span class="citation book">Kilburn, T.; Payne, R. B.; Howarth, D. J. (December 1961). <a rel="nofollow" class="external text" href="http://www.chilton-computing.org.uk/acl/technology/atlas/p019.htm">"The Atlas Supervisor"</a>. <i>Computers - Key to Total Systems Control</i>. Conferences Proceedings. 20 Proceedings of the Eastern Joint Computer Conference Washington, D.C. Macmillan. pp.&#160;279–294.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.atitle=The+Atlas+Supervisor&amp;rft.aufirst=T.&amp;rft.au=Howarth%2C+D.+J.&amp;rft.au=Kilburn%2C+T.&amp;rft.aulast=Kilburn&amp;rft.au=Payne%2C+R.+B.&amp;rft.btitle=Computers+-+Key+to+Total+Systems+Control&amp;rft.date=December+1961&amp;rft.genre=bookitem&amp;rft_id=http%3A%2F%2Fwww.chilton-computing.org.uk%2Facl%2Ftechnology%2Fatlas%2Fp019.htm&amp;rft.pages=279-294&amp;rft.pub=Macmillan&amp;rft.series=Conferences+Proceedings&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.volume=20+Proceedings+of+the+Eastern+Joint+Computer+Conference+Washington%2C+D.C." class="Z3988"><span style="display:none;">&#160;</span></span> <span style="display:none;font-size:100%" class="error citation-comment">Cite uses deprecated parameter <code style="color:inherit; border:inherit; padding:inherit;">|separator=</code> (<a href="/wiki/Help:CS1_errors#deprecated_params" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-16"><span class="mw-cite-backlink"><b><a href="#cite_ref-16">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.linuxjournal.com/article/7105">"Understanding Caching"</a>. Linux Journal<span class="reference-accessdate">. Retrieved <span class="nowrap">2010-05-02</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Understanding+Caching&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.linuxjournal.com%2Farticle%2F7105&amp;rft.pub=Linux+Journal&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-17"><span class="mw-cite-backlink"><b><a href="#cite_ref-17">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external autonumber" href="http://www.systems.ethz.ch/education/courses/fs09/aos/lectures/wk3-print.pdf">[6]</a><sup class="noprint Inline-Template"><span style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Link_rot" title="Wikipedia:Link rot"><span title="&#160;since July 2013">dead link</span></a></i>]</span></sup></span></li>
<li id="cite_note-18"><span class="mw-cite-backlink"><b><a href="#cite_ref-18">^</a></b></span> <span class="reference-text">N.P.Jouppi. "Improving direct-mapped cache performance by the addition of a small fully-associative cache and prefetch buffers." - 17th Annual International Symposium on Computer Architecture, 1990. Proceedings., <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//dx.doi.org/10.1109%2FISCA.1990.134547">10.1109/ISCA.1990.134547</a></span></li>
<li id="cite_note-intel-ark-crystal-well-19"><span class="mw-cite-backlink">^ <a href="#cite_ref-intel-ark-crystal-well_19-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-intel-ark-crystal-well_19-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://ark.intel.com/products/codename/51802/Crystal-Well">"Products (Formerly Crystal Well)"</a>. <a href="/wiki/Intel" title="Intel">Intel</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2013-09-15</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Products+%28Formerly+Crystal+Well%29&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fark.intel.com%2Fproducts%2Fcodename%2F51802%2FCrystal-Well&amp;rft.pub=Intel&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-anandtech-i74950hq-20"><span class="mw-cite-backlink">^ <a href="#cite_ref-anandtech-i74950hq_20-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-anandtech-i74950hq_20-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.anandtech.com/show/6993/intel-iris-pro-5200-graphics-review-core-i74950hq-tested/3">"Intel Iris Pro 5200 Graphics Review: Core i7-4950HQ Tested"</a>. <a href="/wiki/AnandTech" title="AnandTech">AnandTech</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2013-09-16</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Intel+Iris+Pro+5200+Graphics+Review%3A+Core+i7-4950HQ+Tested&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.anandtech.com%2Fshow%2F6993%2Fintel-iris-pro-5200-graphics-review-core-i74950hq-tested%2F3&amp;rft.pub=AnandTech&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-21"><span class="mw-cite-backlink"><b><a href="#cite_ref-21">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.140.2177">"Trace Cache: a Low Latency Approach to High Bandwidth Instruction Fetching."</a>. 1996. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//dx.doi.org/10.1109%2FMICRO.1996.566447">10.1109/MICRO.1996.566447</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Trace+Cache%3A+a+Low+Latency+Approach+to+High+Bandwidth+Instruction+Fetching.&amp;rft.date=1996&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fciteseer.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.140.2177&amp;rft_id=info%3Adoi%2F10.1109%2FMICRO.1996.566447&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-tc-slides-22"><span class="mw-cite-backlink">^ <a href="#cite_ref-tc-slides_22-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-tc-slides_22-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Leon Gu; Dipti Motiani (October 2003). <a rel="nofollow" class="external text" href="http://www.cs.cmu.edu/afs/cs/academic/class/15740-f03/www/lectures/TraceCache_slides.pdf">"Trace Cache"</a> (PDF)<span class="reference-accessdate">. Retrieved <span class="nowrap">2013-10-06</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Dipti+Motiani&amp;rft.aulast=Leon+Gu&amp;rft.au=Leon+Gu&amp;rft.btitle=Trace+Cache&amp;rft.date=October+2003&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.cs.cmu.edu%2Fafs%2Fcs%2Facademic%2Fclass%2F15740-f03%2Fwww%2Flectures%2FTraceCache_slides.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-agner.org-23"><span class="mw-cite-backlink">^ <a href="#cite_ref-agner.org_23-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-agner.org_23-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Agner Fog (2014-02-19). <a rel="nofollow" class="external text" href="http://www.agner.org/optimize/microarchitecture.pdf">"The microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makers"</a> (PDF). agner.org<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-03-21</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Agner+Fog&amp;rft.aulast=Agner+Fog&amp;rft.btitle=The+microarchitecture+of+Intel%2C+AMD+and+VIA+CPUs%3A+An+optimization+guide+for+assembly+programmers+and+compiler+makers&amp;rft.date=2014-02-19&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.agner.org%2Foptimize%2Fmicroarchitecture.pdf&amp;rft.pub=agner.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-uop-intel-24"><span class="mw-cite-backlink">^ <a href="#cite_ref-uop-intel_24-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-uop-intel_24-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Baruch Solomon; Avi Mendelson; Doron Orenstein; Yoav Almog; Ronny Ronen (August 2001). <a rel="nofollow" class="external text" href="http://cecs.uci.edu/~papers/compendium94-03/papers/2001/islped01/pdffiles/p004.pdf">"Micro-Operation Cache: A Power Aware Frontend for Variable Instruction Length ISA"</a> (PDF). <a href="/wiki/Intel" title="Intel">Intel</a>. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//dx.doi.org/10.1109%2FLPE.2001.945363">10.1109/LPE.2001.945363</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2013-10-06</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Avi+Mendelson&amp;rft.au=Baruch+Solomon&amp;rft.au=Doron+Orenstein&amp;rft.aulast=Baruch+Solomon&amp;rft.au=Ronny+Ronen&amp;rft.au=Yoav+Almog&amp;rft.btitle=Micro-Operation+Cache%3A+A+Power+Aware+Frontend+for+Variable+Instruction+Length+ISA&amp;rft.date=August+2001&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fcecs.uci.edu%2F~papers%2Fcompendium94-03%2Fpapers%2F2001%2Fislped01%2Fpdffiles%2Fp004.pdf&amp;rft_id=info%3Adoi%2F10.1109%2FLPE.2001.945363&amp;rft.pub=Intel&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-anandtech-haswell-25"><span class="mw-cite-backlink">^ <a href="#cite_ref-anandtech-haswell_25-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-anandtech-haswell_25-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Anand Lal Shimpi (2012-10-05). <a rel="nofollow" class="external text" href="http://www.anandtech.com/show/6355/intels-haswell-architecture/6">"Intel's Haswell Architecture Analyzed"</a>. <a href="/wiki/AnandTech" title="AnandTech">AnandTech</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2013-10-20</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Anand+Lal+Shimpi&amp;rft.aulast=Anand+Lal+Shimpi&amp;rft.btitle=Intel%27s+Haswell+Architecture+Analyzed&amp;rft.date=2012-10-05&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.anandtech.com%2Fshow%2F6355%2Fintels-haswell-architecture%2F6&amp;rft.pub=AnandTech&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-26"><span class="mw-cite-backlink"><b><a href="#cite_ref-26">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.anandtech.com/show/6993/intel-iris-pro-5200-graphics-review-core-i74950hq-tested/3">"Intel Iris Pro 5200 Graphics Review: Core i7-4950HQ Tested"</a>. AnandTech<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-02-25</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Intel+Iris+Pro+5200+Graphics+Review%3A+Core+i7-4950HQ+Tested&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.anandtech.com%2Fshow%2F6993%2Fintel-iris-pro-5200-graphics-review-core-i74950hq-tested%2F3&amp;rft.pub=AnandTech&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-27"><span class="mw-cite-backlink"><b><a href="#cite_ref-27">^</a></b></span> <span class="reference-text"><span class="citation web">Oded Lempel (2013-07-28). <a rel="nofollow" class="external text" href="http://www.hotchips.org/wp-content/uploads/hc_archives/hc23/HC23.19.9-Desktop-CPUs/HC23.19.911-Sandy-Bridge-Lempel-Intel-Rev%207.pdf">"2nd Generation Intel Core Processor Family: Intel Core i7, i5 and i3"</a> (PDF). hotchips.org. p.&#160;7–10,31–45<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-01-21</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.aulast=Oded+Lempel&amp;rft.au=Oded+Lempel&amp;rft.btitle=2nd+Generation+Intel+Core+Processor+Family%3A+Intel+Core+i7%2C+i5+and+i3&amp;rft.date=2013-07-28&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.hotchips.org%2Fwp-content%2Fuploads%2Fhc_archives%2Fhc23%2FHC23.19.9-Desktop-CPUs%2FHC23.19.911-Sandy-Bridge-Lempel-Intel-Rev%25207.pdf&amp;rft.pages=7-10%2C31-45&amp;rft.pub=hotchips.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-28"><span class="mw-cite-backlink"><b><a href="#cite_ref-28">^</a></b></span> <span class="reference-text"><span class="citation journal">Chen, J. Bradley; Borg, Anita; Jouppi, Norman P. (1992). "A Simulation Based Study of TLB Performance". <i>SIGARCH Computer Architecture News</i> (20): 114–123. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//dx.doi.org/10.1145%2F146628.139708">10.1145/146628.139708</a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.atitle=A+Simulation+Based+Study+of+TLB+Performance&amp;rft.au=Borg%2C+Anita&amp;rft.au=Chen%2C+J.+Bradley&amp;rft.au=Jouppi%2C+Norman+P.&amp;rft.aulast=Chen%2C+J.+Bradley&amp;rft.date=1992&amp;rft.genre=article&amp;rft_id=info%3Adoi%2F10.1145%2F146628.139708&amp;rft.issue=20&amp;rft.jtitle=SIGARCH+Computer+Architecture+News&amp;rft.pages=114-123&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-29"><span class="mw-cite-backlink"><b><a href="#cite_ref-29">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.amecomputers.com/explanation-of-the-l1-and-l2-cache.html">"Explanation of the L1 and L2 Cache"</a>. amecomputers.com<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-06-09</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Explanation+of+the+L1+and+L2+Cache&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.amecomputers.com%2Fexplanation-of-the-l1-and-l2-cache.html&amp;rft.pub=amecomputers.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-ispass04-30"><span class="mw-cite-backlink">^ <a href="#cite_ref-ispass04_30-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-ispass04_30-1"><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-ispass04_30-2"><sup><i><b>c</b></i></sup></a></span> <span class="reference-text"><span class="citation web">Ying Zheng; Brian T. Davis; Matthew Jordan (2004-06-25). <a rel="nofollow" class="external text" href="http://mercury.pr.erau.edu/~davisb22/papers/ispass04.pdf">"Performance Evaluation of Exclusive Cache Hierarchies"</a> (PDF). Michigan Technological University<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-06-09</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Brian+T.+Davis&amp;rft.aulast=Ying+Zheng&amp;rft.au=Matthew+Jordan&amp;rft.au=Ying+Zheng&amp;rft.btitle=Performance+Evaluation+of+Exclusive+Cache+Hierarchies&amp;rft.date=2004-06-25&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fmercury.pr.erau.edu%2F~davisb22%2Fpapers%2Fispass04.pdf&amp;rft.pub=Michigan+Technological+University&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-31"><span class="mw-cite-backlink"><b><a href="#cite_ref-31">^</a></b></span> <span class="reference-text"><span class="citation web">Aamer Jaleel; Eric Borch; Malini Bhandaru; Simon C. Steely Jr.; Joel Emer (2010-09-27). <a rel="nofollow" class="external text" href="http://www.jaleels.org/ajaleel/publications/micro2010-tla.pdf">"Achieving Non-Inclusive Cache Performance with Inclusive Caches"</a> (PDF). jaleels.org<span class="reference-accessdate">. Retrieved <span class="nowrap">2014-06-09</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=Aamer+Jaleel&amp;rft.au=Eric+Borch&amp;rft.au=Joel+Emer&amp;rft.aulast=Aamer+Jaleel&amp;rft.au=Malini+Bhandaru&amp;rft.au=Simon+C.+Steely+Jr.&amp;rft.btitle=Achieving+Non-Inclusive+Cache+Performance+with+Inclusive+Caches&amp;rft.date=2010-09-27&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.jaleels.org%2Fajaleel%2Fpublications%2Fmicro2010-tla.pdf&amp;rft.pub=jaleels.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-32"><span class="mw-cite-backlink"><b><a href="#cite_ref-32">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.sandpile.org/impl/k8.htm">"AMD K8"</a>. Sandpile.org<span class="reference-accessdate">. Retrieved <span class="nowrap">2007-06-02</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=AMD+K8&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.sandpile.org%2Fimpl%2Fk8.htm&amp;rft.pub=Sandpile.org&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-33"><span class="mw-cite-backlink"><b><a href="#cite_ref-33">^</a></b></span> <span class="reference-text"><span class="citation web">Mahapatra, Nihar R.; Venkatrao, Balakrishna. <a rel="nofollow" class="external text" href="https://epic.hpi.uni-potsdam.de/pub/Home/TrendsAndConceptsII2010/HW_Trends_The_Processor-Memory_bottleneck___Problems_and_Solutions..pdf">"The processor-memory bottleneck: problems and solutions"</a>. Association of Computing Machinery. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a rel="nofollow" class="external text" href="//dx.doi.org/10.1145%2F357783.331677">10.1145/357783.331677</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2013-03-05</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.aufirst=Nihar+R.&amp;rft.aulast=Mahapatra&amp;rft.au=Mahapatra%2C+Nihar+R.&amp;rft.au=Venkatrao%2C+Balakrishna&amp;rft.btitle=The+processor-memory+bottleneck%3A+problems+and+solutions&amp;rft.genre=book&amp;rft_id=https%3A%2F%2Fepic.hpi.uni-potsdam.de%2Fpub%2FHome%2FTrendsAndConceptsII2010%2FHW_Trends_The_Processor-Memory_bottleneck___Problems_and_Solutions..pdf&amp;rft_id=info%3Adoi%2F10.1145%2F357783.331677&amp;rft.pub=Association+of+Computing+Machinery&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-34"><span class="mw-cite-backlink"><b><a href="#cite_ref-34">^</a></b></span> <span class="reference-text"><span class="citation book">GE (January 1968). <a rel="nofollow" class="external text" href="http://bitsavers.org/pdf/ge/GE-645/GE-645_SystemMan_Jan68.pdf"><i>GE-645 System Manual</i></a>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=GE&amp;rft.aulast=GE&amp;rft.btitle=GE-645+System+Manual&amp;rft.date=January+1968&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbitsavers.org%2Fpdf%2Fge%2FGE-645%2FGE-645_SystemMan_Jan68.pdf&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span> <span style="display:none;font-size:100%" class="error citation-comment">Cite uses deprecated parameter <code style="color:inherit; border:inherit; padding:inherit;">|separator=</code> (<a href="/wiki/Help:CS1_errors#deprecated_params" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-35"><span class="mw-cite-backlink"><b><a href="#cite_ref-35">^</a></b></span> <span class="reference-text"><span class="citation book">IBM (February 1972). <a rel="nofollow" class="external text" href="http://www.bitsavers.org/pdf/ibm/360/funcChar/GA27-2719-2_360-67_funcChar.pdf"><i>IBM System/360 Model 67 Functional Characteristics</i></a>. Third Edition. GA27-2719-2.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=IBM&amp;rft.aulast=IBM&amp;rft.btitle=IBM+System%2F360+Model+67+Functional+Characteristics&amp;rft.date=February+1972&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.bitsavers.org%2Fpdf%2Fibm%2F360%2FfuncChar%2FGA27-2719-2_360-67_funcChar.pdf&amp;rft.series=Third+Edition&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span> <span style="display:none;font-size:100%" class="error citation-comment">Cite uses deprecated parameter <code style="color:inherit; border:inherit; padding:inherit;">|separator=</code> (<a href="/wiki/Help:CS1_errors#deprecated_params" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-36"><span class="mw-cite-backlink"><b><a href="#cite_ref-36">^</a></b></span> <span class="reference-text"><span class="citation book">IBM (June 1968). <a rel="nofollow" class="external text" href="http://www.bitsavers.org/pdf/ibm/360/funcChar/A22-6916-1_360-85_funcChar_Jun68.pdf"><i>IBM System/360 Model 85 Functional Characteristics</i></a>. SECOND EDITION. A22-6916-1.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.au=IBM&amp;rft.aulast=IBM&amp;rft.btitle=IBM+System%2F360+Model+85+Functional+Characteristics&amp;rft.date=June+1968&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.bitsavers.org%2Fpdf%2Fibm%2F360%2FfuncChar%2FA22-6916-1_360-85_funcChar_Jun68.pdf&amp;rft.series=SECOND+EDITION&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span> <span style="display:none;font-size:100%" class="error citation-comment">Cite uses deprecated parameter <code style="color:inherit; border:inherit; padding:inherit;">|separator=</code> (<a href="/wiki/Help:CS1_errors#deprecated_params" title="Help:CS1 errors">help</a>)</span></span></li>
<li id="cite_note-37"><span class="mw-cite-backlink"><b><a href="#cite_ref-37">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://ark.intel.com/products/family/59139/Intel-Xeon-Processor-E7-Family/server">"Intel® Xeon® Processor E7 Family"</a>. <a href="/wiki/Intel" title="Intel">Intel</a><span class="reference-accessdate">. Retrieved <span class="nowrap">2013-10-10</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=Intel%C2%AE+Xeon%C2%AE+Processor+E7+Family&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fark.intel.com%2Fproducts%2Ffamily%2F59139%2FIntel-Xeon-Processor-E7-Family%2Fserver&amp;rft.pub=Intel&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-38"><span class="mw-cite-backlink"><b><a href="#cite_ref-38">^</a></b></span> <span class="reference-text">"<a rel="nofollow" class="external text" href="https://www.academia.edu/5010517/A_Survey_of_Architectural_Techniques_For_Improving_Cache_Power_Efficiency">A Survey of Architectural Techniques For Improving Cache Power Efficiency</a>", S. Mittal, SUSCOM, 4(1), 33-43, 2014</span></li>
<li id="cite_note-39"><span class="mw-cite-backlink"><b><a href="#cite_ref-39">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="http://spectrum.ieee.org/computing/hardware/chip-design-thwarts-sneak-attack-on-data">"Chip Design Thwarts Sneak Attack on Data"</a> by Sally Adee 2009 discusses "A novel cache architecture with enhanced performance and security" <a rel="nofollow" class="external autonumber" href="http://portal.acm.org/citation.cfm?id=1521781">[7]</a> <a rel="nofollow" class="external autonumber" href="http://palms.princeton.edu/system/files/Micro08_Newcache.pdf">[8]</a> by Zhenghong Wang and Ruby B. Lee: (abstract) "Caches ideally should have low miss rates and short access times, and should be power efficient at the same time. Such design goals are often contradictory in practice."</span></li>
<li id="cite_note-40"><span class="mw-cite-backlink"><b><a href="#cite_ref-40">^</a></b></span> <span class="reference-text">"<a rel="nofollow" class="external text" href="https://www.academia.edu/6988421/A_Survey_Of_Architectural_Approaches_for_Managing_Embedded_DRAM_and_Non-volatile_On-chip_Caches">A Survey Of Architectural Approaches for Managing Embedded DRAM and Non-volatile On-chip Caches</a>", Mittal et al., IEEE TPDS, 2014.</span></li>
<li id="cite_note-41"><span class="mw-cite-backlink"><b><a href="#cite_ref-41">^</a></b></span> <span class="reference-text"><span class="citation web"><a rel="nofollow" class="external text" href="http://www.hpl.hp.com/research/cacti/">"CACTI"</a>. Hpl.hp.com<span class="reference-accessdate">. Retrieved <span class="nowrap">2010-05-02</span></span>.</span><span title="ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ACPU+cache&amp;rft.btitle=CACTI&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fwww.hpl.hp.com%2Fresearch%2Fcacti%2F&amp;rft.pub=Hpl.hp.com&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook" class="Z3988"><span style="display:none;">&#160;</span></span></span></li>
<li id="cite_note-42"><span class="mw-cite-backlink"><b><a href="#cite_ref-42">^</a></b></span> <span class="reference-text"><a rel="nofollow" class="external text" href="https://code.ornl.gov/3d_cache_modeling_tool/destiny/blob/master/README">3d_cache_modeling_tool / destiny</a>, code.ornl.gov, Retrieved 2015-02-26.</span></li>
</ol>
</div>
<h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=CPU_cache&amp;action=edit&amp;section=43" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table class="mbox-small plainlinks" style="border:1px solid #aaa;background-color:#f9f9f9">
<tr>
<td class="mbox-image"><img alt="" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/40px-Wikibooks-logo-en-noslogan.svg.png" width="40" height="40" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/60px-Wikibooks-logo-en-noslogan.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/80px-Wikibooks-logo-en-noslogan.svg.png 2x" data-file-width="400" data-file-height="400" /></td>
<td class="mbox-text plainlist">The Wikibook <i><a href="//en.wikibooks.org/wiki/Microprocessor_Design" class="extiw" title="wikibooks:Microprocessor Design">Microprocessor Design</a></i> has a page on the topic of: <i><b><a href="//en.wikibooks.org/wiki/Microprocessor_Design/Cache" class="extiw" title="wikibooks:Microprocessor Design/Cache">Cache</a></b></i></td>
</tr>
</table>
<ul>
<li><a rel="nofollow" class="external text" href="http://lwn.net/Articles/252125/">Memory part 2: CPU caches</a>&#160;–  an article on lwn.net by Ulrich Drepper describing CPU caches in detail.</li>
<li><a rel="nofollow" class="external text" href="ftp://ftp.cs.wisc.edu/markhill/Papers/toc89_cpu_cache_associativity.pdf">Evaluating Associativity in CPU Caches</a> — Hill and Smith — 1989 — Introduces capacity, conflict, and compulsory classification.</li>
<li><a rel="nofollow" class="external text" href="http://www.cs.wisc.edu/multifacet/misc/spec2000cache-data/">Cache Performance for SPEC CPU2000 Benchmarks</a> — Hill and Cantin — 2003 — This reference paper has been updated several times. It has thorough and lucidly presented simulation results for a reasonably wide set of benchmarks and cache organizations.</li>
<li><a rel="nofollow" class="external text" href="http://www.sun.com/blueprints/1102/817-0742.pdf">Memory Hierarchy in Cache-Based Systems</a>, by Ruud van der Pas, 2002, Sun Microsystems, is a nice introductory article to CPU memory caching.</li>
<li><a rel="nofollow" class="external text" href="http://www.freescale.com/files/32bit/doc/app_note/AN2663.pdf">A Cache Primer</a> by Paul Genua, P.E., 2004, Freescale Semiconductor, another introductory article.</li>
<li><a rel="nofollow" class="external text" href="http://www.zipcores.com/skin1/zipdocs/datasheets/cache_8way_set.pdf">An 8-way set-associative cache</a>&#160;–  written in <a href="/wiki/VHDL" title="VHDL">VHDL</a></li>
<li><a rel="nofollow" class="external text" href="http://arstechnica.com/old/content/2002/07/caching.ars">Understanding CPU caching and performance</a>&#160;–  an article on Ars Technica by Jon Stokes.</li>
<li><a rel="nofollow" class="external text" href="http://ixbtlabs.com/articles/ibmpower4/">IBM POWER4 processor review</a>&#160;–  an article on ixbtlabs by Pavel Danilov</li>
<li><a rel="nofollow" class="external text" href="http://www.cs.princeton.edu/courses/archive/fall04/cos471/lectures/17-Cache.pdf">Memory Caching</a>&#160;–  a Princeton University lecture</li>
</ul>
<table class="navbox" style="border-spacing:0">
<tr>
<td style="padding:2px">
<table class="nowraplinks collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit">
<tr>
<th scope="col" class="navbox-title" colspan="2">
<div class="plainlinks hlist navbar mini">
<ul>
<li class="nv-view"><a href="/wiki/Template:CPU_technologies" title="Template:CPU technologies"><span title="View this template" style=";;background:none transparent;border:none;">v</span></a></li>
<li class="nv-talk"><a href="/wiki/Template_talk:CPU_technologies" title="Template talk:CPU technologies"><span title="Discuss this template" style=";;background:none transparent;border:none;">t</span></a></li>
<li class="nv-edit"><a class="external text" href="//en.wikipedia.org/w/index.php?title=Template:CPU_technologies&amp;action=edit"><span title="Edit this template" style=";;background:none transparent;border:none;">e</span></a></li>
</ul>
</div>
<div style="font-size:110%"><a href="/wiki/Central_processing_unit" title="Central processing unit">CPU technologies</a></div>
</th>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Computer_architecture" title="Computer architecture">Architecture</a></th>
<td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Harvard_architecture" title="Harvard architecture">Harvard</a> (<a href="/wiki/Modified_Harvard_architecture" title="Modified Harvard architecture">Modified Harvard</a>)</li>
<li><a href="/wiki/Von_Neumann_architecture" title="Von Neumann architecture">von Neumann</a></li>
<li><a href="/wiki/Dataflow_architecture" title="Dataflow architecture">Dataflow</a></li>
<li><a href="/wiki/Transport_triggered_architecture" title="Transport triggered architecture">TTA</a></li>
<li><a href="/wiki/Comparison_of_instruction_set_architectures" title="Comparison of instruction set architectures">Comparison</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Instruction_set" title="Instruction set">Instruction set</a></th>
<td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Application-specific_instruction-set_processor" title="Application-specific instruction-set processor" class="mw-redirect">ASIP</a></li>
<li><a href="/wiki/Complex_instruction_set_computing" title="Complex instruction set computing">CISC</a></li>
<li><a href="/wiki/Explicit_Data_Graph_Execution" title="Explicit Data Graph Execution">EDGE</a></li>
<li><a href="/wiki/Explicitly_parallel_instruction_computing" title="Explicitly parallel instruction computing">EPIC</a></li>
<li><a href="/wiki/Minimal_instruction_set_computer" title="Minimal instruction set computer">MISC</a></li>
<li><a href="/wiki/One_instruction_set_computer" title="One instruction set computer">OISC</a></li>
<li><a href="/wiki/Reduced_instruction_set_computing" title="Reduced instruction set computing">RISC</a></li>
<li><a href="/wiki/Very_long_instruction_word" title="Very long instruction word">VLIW</a></li>
<li><a href="/wiki/No_instruction_set_computing" title="No instruction set computing">NISC</a></li>
<li><a href="/wiki/Zero_instruction_set_computer" title="Zero instruction set computer">ZISC</a></li>
<li><a href="/wiki/TRIPS_architecture" title="TRIPS architecture">TRIPS</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word size</a></th>
<td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/1-bit_architecture" title="1-bit architecture">1-bit</a></li>
<li><a href="/wiki/4-bit" title="4-bit">4-bit</a></li>
<li><a href="/wiki/8-bit" title="8-bit">8-bit</a></li>
<li><a href="/wiki/Word_(computer_architecture)#Table_of_word_sizes" title="Word (computer architecture)">9-bit</a></li>
<li><a href="/wiki/Ferranti_Mercury" title="Ferranti Mercury">10-bit</a></li>
<li><a href="/wiki/12-bit" title="12-bit">12-bit</a></li>
<li><a href="/wiki/Apollo_Guidance_Computer" title="Apollo Guidance Computer">15-bit</a></li>
<li><a href="/wiki/16-bit" title="16-bit">16-bit</a></li>
<li><a href="/wiki/18-bit" title="18-bit">18-bit</a></li>
<li><a href="/wiki/Z3_(computer)" title="Z3 (computer)">22-bit</a></li>
<li><a href="/wiki/24-bit" title="24-bit">24-bit</a></li>
<li><a href="/wiki/UNIVAC_III" title="UNIVAC III">25-bit</a></li>
<li><a href="/wiki/Saturn_Launch_Vehicle_Digital_Computer" title="Saturn Launch Vehicle Digital Computer">26-bit</a></li>
<li><a href="/wiki/D-17B" title="D-17B">27-bit</a></li>
<li><a href="/wiki/31-bit" title="31-bit">31-bit</a></li>
<li><a href="/wiki/32-bit" title="32-bit">32-bit</a></li>
<li><a href="/wiki/ZEBRA_(computer)" title="ZEBRA (computer)">33-bit</a></li>
<li><a href="/wiki/Fast_Universal_Digital_Computer_M-2" title="Fast Universal Digital Computer M-2">34-bit</a></li>
<li><a href="/wiki/36-bit" title="36-bit">36-bit</a></li>
<li><a href="/wiki/Word_(computer_architecture)#Table_of_word_sizes" title="Word (computer architecture)">39-bit</a></li>
<li><a href="/wiki/IAS_machine" title="IAS machine">40-bit</a></li>
<li><a href="/wiki/48-bit" title="48-bit">48-bit</a></li>
<li><a href="/wiki/Atanasoff%E2%80%93Berry_computer" title="Atanasoff–Berry computer">50-bit</a></li>
<li><a href="/wiki/60-bit" title="60-bit">60-bit</a></li>
<li><a href="/wiki/64-bit_computing" title="64-bit computing">64-bit</a></li>
<li><a href="/wiki/128-bit" title="128-bit">128-bit</a></li>
<li><a href="/wiki/256-bit" title="256-bit">256-bit</a></li>
<li><a href="/wiki/512-bit" title="512-bit">512-bit</a></li>
<li><a href="/wiki/Word_(computer_architecture)#Variable_word_architectures" title="Word (computer architecture)">variable</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Instruction_cycle" title="Instruction cycle">Execution</a></th>
<td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Instruction_pipeline" title="Instruction pipeline">Instruction pipelining</a>
<ul>
<li><a href="/wiki/Bubble_(computing)" title="Bubble (computing)">Bubble</a></li>
<li><a href="/wiki/Operand_forwarding" title="Operand forwarding">Operand forwarding</a></li>
</ul>
</li>
<li><a href="/wiki/Out-of-order_execution" title="Out-of-order execution">Out-of-order execution</a>
<ul>
<li><a href="/wiki/Register_renaming" title="Register renaming">Register renaming</a></li>
</ul>
</li>
<li><a href="/wiki/Speculative_execution" title="Speculative execution">Speculative execution</a>
<ul>
<li><a href="/wiki/Branch_predictor" title="Branch predictor">Branch predictor</a></li>
<li><a href="/wiki/Memory_dependence_prediction" title="Memory dependence prediction">Memory dependence prediction</a></li>
</ul>
</li>
<li><a href="/wiki/Hazard_(computer_architecture)" title="Hazard (computer architecture)">Hazards</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Parallel_computing" title="Parallel computing">Parallel level</a></th>
<td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Bit-level_parallelism" title="Bit-level parallelism">Bit</a>
<ul>
<li><a href="/wiki/Bit-serial_architecture" title="Bit-serial architecture">Bit-serial</a></li>
<li><a href="/wiki/Word_(computer_architecture)" title="Word (computer architecture)">Word</a></li>
</ul>
</li>
<li><a href="/wiki/Instruction-level_parallelism" title="Instruction-level parallelism">Instruction</a>
<ul>
<li><a href="/wiki/Scalar_processor" title="Scalar processor">Scalar</a></li>
<li><a href="/wiki/Superscalar" title="Superscalar">Superscalar</a></li>
</ul>
</li>
<li><a href="/wiki/Data_parallelism" title="Data parallelism">Data</a>
<ul>
<li><a href="/wiki/Vector_processor" title="Vector processor">Vector</a></li>
</ul>
</li>
<li><a href="/wiki/Memory-level_parallelism" title="Memory-level parallelism">Memory</a></li>
<li><a href="/wiki/Task_parallelism" title="Task parallelism">Task</a>
<ul>
<li><a href="/wiki/Thread_(computing)" title="Thread (computing)">Thread</a></li>
</ul>
</li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Multithreading_(computer_architecture)" title="Multithreading (computer architecture)">Multithreading</a></th>
<td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Temporal_multithreading" title="Temporal multithreading">Temporal multithreading</a></li>
<li><a href="/wiki/Simultaneous_multithreading" title="Simultaneous multithreading">Simultaneous multithreading</a>
<ul>
<li><a href="/wiki/Hyper-threading" title="Hyper-threading">Hyper-threading</a></li>
</ul>
</li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Flynn%27s_taxonomy" title="Flynn's taxonomy">Flynn's taxonomy</a></th>
<td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/SISD" title="SISD">SISD</a></li>
<li><a href="/wiki/SIMD" title="SIMD">SIMD</a></li>
<li><a href="/wiki/MISD" title="MISD">MISD</a></li>
<li><a href="/wiki/MIMD" title="MIMD">MIMD</a>
<ul>
<li><a href="/wiki/SPMD" title="SPMD">SPMD</a></li>
</ul>
</li>
<li><a href="/wiki/Addressing_mode" title="Addressing mode">Addressing mode</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group">Types</th>
<td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Digital_signal_processor" title="Digital signal processor">Digital signal processor</a> (DSP)</li>
<li><a href="/wiki/General-purpose_computing_on_graphics_processing_units" title="General-purpose computing on graphics processing units">GPGPU</a></li>
<li><a href="/wiki/Microcontroller" title="Microcontroller">Microcontroller</a></li>
<li><a href="/wiki/Physics_processing_unit" title="Physics processing unit">Physics processing unit</a></li>
<li><a href="/wiki/System_on_a_chip" title="System on a chip">System on a chip</a> (SoC)</li>
<li><a href="/wiki/Cellular_architecture" title="Cellular architecture">Cellular</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group">Components</th>
<td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Address_generation_unit" title="Address generation unit">Address generation unit</a> (AGU)</li>
<li><a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">Arithmetic logic unit</a> (ALU)</li>
<li><a href="/wiki/Barrel_shifter" title="Barrel shifter">Barrel shifter</a></li>
<li><a href="/wiki/Floating-point_unit" title="Floating-point unit">Floating-point unit</a> (FPU)</li>
<li><a href="/wiki/Back-side_bus" title="Back-side bus">Back-side bus</a></li>
<li>(<a href="/wiki/Multiplexer" title="Multiplexer">Multiplexer</a>, <a href="/wiki/Demultiplexer" title="Demultiplexer" class="mw-redirect">Demultiplexer</a>)</li>
<li><a href="/wiki/Processor_register" title="Processor register">Registers</a></li>
<li><a href="/wiki/Memory_management_unit" title="Memory management unit">Memory management unit</a> (MMU)</li>
<li><a href="/wiki/Translation_lookaside_buffer" title="Translation lookaside buffer">Translation lookaside buffer</a> (TLB)</li>
<li><strong class="selflink">Cache</strong></li>
<li><a href="/wiki/Register_file" title="Register file">Register file</a></li>
<li><a href="/wiki/Microcode" title="Microcode">Microcode</a></li>
<li><a href="/wiki/Control_unit" title="Control unit">Control unit</a></li>
<li><a href="/wiki/Clock_rate" title="Clock rate">Clock rate</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group"><a href="/wiki/Power_management" title="Power management">Power<br />
management</a></th>
<td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/Advanced_Power_Management" title="Advanced Power Management">APM</a></li>
<li><a href="/wiki/Advanced_Configuration_and_Power_Interface" title="Advanced Configuration and Power Interface">ACPI</a></li>
<li><a href="/wiki/Dynamic_frequency_scaling" title="Dynamic frequency scaling">Dynamic frequency scaling</a></li>
<li><a href="/wiki/Dynamic_voltage_scaling" title="Dynamic voltage scaling">Dynamic voltage scaling</a></li>
<li><a href="/wiki/Clock_gating" title="Clock gating">Clock gating</a></li>
</ul>
</div>
</td>
</tr>
<tr style="height:2px">
<td colspan="2"></td>
</tr>
<tr>
<th scope="row" class="navbox-group">CPU hardware <a href="/wiki/Computer_security" title="Computer security">security</a></th>
<td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px">
<div style="padding:0em 0.25em">
<ul>
<li><a href="/wiki/NX_bit" title="NX bit">NX bit</a></li>
<li><a href="/wiki/Hardware_restriction" title="Hardware restriction">Hardware restriction</a> (<a href="/wiki/Firmware" title="Firmware">firmware</a>)</li>
<li><a href="/wiki/Trusted_Execution_Technology" title="Trusted Execution Technology">Trusted Execution Technology</a></li>
<li><a href="/wiki/Secure_cryptoprocessor" title="Secure cryptoprocessor">Secure cryptoprocessor</a></li>
<li><a href="/wiki/Hardware_security_module" title="Hardware security module">Hardware security module</a></li>
<li><a href="/wiki/Hengzhi_chip" title="Hengzhi chip">Hengzhi chip</a></li>
</ul>
</div>
</td>
</tr>
</table>
</td>
</tr>
</table>


<!-- 
NewPP limit report
Parsed by mw1066
CPU time usage: 0.677 seconds
Real time usage: 0.798 seconds
Preprocessor visited node count: 3421/1000000
Preprocessor generated node count: 0/1500000
Post‐expand include size: 82470/2097152 bytes
Template argument size: 3645/2097152 bytes
Highest expansion depth: 12/40
Expensive parser function count: 5/500
Lua time usage: 0.183/10.000 seconds
Lua memory usage: 4.15 MB/50 MB
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%  558.192      1 - -total
 44.34%  247.511      2 - Template:Reflist
 18.89%  105.452     20 - Template:Cite_web
 12.48%   69.639      1 - Template:Merge_from
  7.94%   44.322      1 - Template:Mbox
  5.35%   29.861      1 - Template:Redirect
  4.49%   25.046      3 - Template:Fix
  4.36%   24.330     11 - Template:Anchor
  4.23%   23.607      1 - Template:CPU_technologies
  3.58%   19.983      1 - Template:Navbox
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:849181-0!*!0!!en!4!*!math=0 and timestamp 20150303163124 and revision id 649703928
 -->
<noscript><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript></div>									<div class="printfooter">
						Retrieved from "<a dir="ltr" href="http://en.wikipedia.org/w/index.php?title=CPU_cache&amp;oldid=649703928">http://en.wikipedia.org/w/index.php?title=CPU_cache&amp;oldid=649703928</a>"					</div>
													<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Help:Category" title="Help:Category">Categories</a>: <ul><li><a href="/wiki/Category:Central_processing_unit" title="Category:Central processing unit">Central processing unit</a></li><li><a href="/wiki/Category:Computer_memory" title="Category:Computer memory">Computer memory</a></li><li><a href="/wiki/Category:Cache_(computing)" title="Category:Cache (computing)">Cache (computing)</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden categories: <ul><li><a href="/wiki/Category:Pages_containing_cite_templates_with_deprecated_parameters" title="Category:Pages containing cite templates with deprecated parameters">Pages containing cite templates with deprecated parameters</a></li><li><a href="/wiki/Category:All_articles_with_dead_external_links" title="Category:All articles with dead external links">All articles with dead external links</a></li><li><a href="/wiki/Category:Articles_with_dead_external_links_from_July_2013" title="Category:Articles with dead external links from July 2013">Articles with dead external links from July 2013</a></li><li><a href="/wiki/Category:Articles_to_be_merged_from_July_2013" title="Category:Articles to be merged from July 2013">Articles to be merged from July 2013</a></li><li><a href="/wiki/Category:All_articles_to_be_merged" title="Category:All articles to be merged">All articles to be merged</a></li><li><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></li><li><a href="/wiki/Category:Articles_with_unsourced_statements_from_March_2008" title="Category:Articles with unsourced statements from March 2008">Articles with unsourced statements from March 2008</a></li><li><a href="/wiki/Category:All_accuracy_disputes" title="Category:All accuracy disputes">All accuracy disputes</a></li><li><a href="/wiki/Category:Articles_with_disputed_statements_from_December_2010" title="Category:Articles with disputed statements from December 2010">Articles with disputed statements from December 2010</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>

			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-createaccount"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=CPU+cache&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=CPU+cache" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
															<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/CPU_cache"  title="View the content page [c]" accesskey="c">Article</a></span></li>
															<li  id="ca-talk"><span><a href="/wiki/Talk:CPU_cache"  title="Discussion about the content page [t]" accesskey="t">Talk</a></span></li>
													</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
															<li id="ca-view" class="selected"><span><a href="/wiki/CPU_cache" >Read</a></span></li>
															<li id="ca-edit"><span><a href="/w/index.php?title=CPU_cache&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
															<li id="ca-history" class="collapsible"><span><a href="/w/index.php?title=CPU_cache&amp;action=history"  title="Past versions of this page [h]" accesskey="h" rel="archives">View history</a></span></li>
													</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span><a href="#"></a></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="/w/index.php" id="searchform">
														<div id="simpleSearch">
															<input type="search" name="search" placeholder="Search" title="Search Wikipedia [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search Wikipedia for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if one exists" id="searchButton" class="searchButton" />								</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
			<h3 id='p-navigation-label'>Navigation</h3>

			<div class="body">
									<ul>
													<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
													<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
													<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content – the best of Wikipedia">Featured content</a></li>
													<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
													<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
													<li id="n-sitesupport"><a href="https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikipedia.org&amp;uselang=en" title="Support us">Donate to Wikipedia</a></li>
													<li id="n-shoplink"><a href="//shop.wikimedia.org" title="Visit the Wikimedia Shop">Wikimedia Shop</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-interaction' aria-labelledby='p-interaction-label'>
			<h3 id='p-interaction-label'>Interaction</h3>

			<div class="body">
									<ul>
													<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
													<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
													<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
													<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
													<li id="n-contactpage"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact page</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
			<h3 id='p-tb-label'>Tools</h3>

			<div class="body">
									<ul>
													<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/CPU_cache" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
													<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/CPU_cache" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
													<li id="t-upload"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Upload files [u]" accesskey="u">Upload file</a></li>
													<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
													<li id="t-permalink"><a href="/w/index.php?title=CPU_cache&amp;oldid=649703928" title="Permanent link to this revision of the page">Permanent link</a></li>
													<li id="t-info"><a href="/w/index.php?title=CPU_cache&amp;action=info" title="More information about this page">Page information</a></li>
													<li id="t-wikibase"><a href="//www.wikidata.org/wiki/Q352090" title="Link to connected data repository item [g]" accesskey="g">Wikidata item</a></li>
						<li id="t-cite"><a href="/w/index.php?title=Special:CiteThisPage&amp;page=CPU_cache&amp;id=649703928" title="Information on how to cite this page">Cite this page</a></li>					</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-coll-print_export' aria-labelledby='p-coll-print_export-label'>
			<h3 id='p-coll-print_export-label'>Print/export</h3>

			<div class="body">
									<ul>
													<li id="coll-create_a_book"><a href="/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=CPU+cache">Create a book</a></li>
													<li id="coll-download-as-rdf2latex"><a href="/w/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=CPU+cache&amp;oldid=649703928&amp;writer=rdf2latex">Download as PDF</a></li>
													<li id="t-print"><a href="/w/index.php?title=CPU_cache&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
											</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id='p-lang' aria-labelledby='p-lang-label'>
			<h3 id='p-lang-label'>Languages</h3>

			<div class="body">
									<ul>
													<li class="interlanguage-link interwiki-et"><a href="//et.wikipedia.org/wiki/Protsessori_vahem%C3%A4lu" title="Protsessori vahemälu – Estonian" lang="et" hreflang="et">Eesti</a></li>
													<li class="interlanguage-link interwiki-es"><a href="//es.wikipedia.org/wiki/Cach%C3%A9_de_CPU" title="Caché de CPU – Spanish" lang="es" hreflang="es">Español</a></li>
													<li class="interlanguage-link interwiki-fa"><a href="//fa.wikipedia.org/wiki/%D8%AD%D8%A7%D9%81%D8%B8%D9%87_%D9%86%D9%87%D8%A7%D9%86_%D8%B3%DB%8C%E2%80%8C%D9%BE%DB%8C%E2%80%8C%DB%8C%D9%88" title="حافظه نهان سی‌پی‌یو – Persian" lang="fa" hreflang="fa">فارسی</a></li>
													<li class="interlanguage-link interwiki-ga"><a href="//ga.wikipedia.org/wiki/Taisc-chuimhne" title="Taisc-chuimhne – Irish" lang="ga" hreflang="ga">Gaeilge</a></li>
													<li class="interlanguage-link interwiki-ko"><a href="//ko.wikipedia.org/wiki/CPU_%EC%BA%90%EC%8B%9C" title="CPU 캐시 – Korean" lang="ko" hreflang="ko">한국어</a></li>
													<li class="interlanguage-link interwiki-hr"><a href="//hr.wikipedia.org/wiki/L1_priru%C4%8Dna_memorija" title="L1 priručna memorija – Croatian" lang="hr" hreflang="hr">Hrvatski</a></li>
													<li class="interlanguage-link interwiki-id"><a href="//id.wikipedia.org/wiki/Tembolok_CPU" title="Tembolok CPU – Indonesian" lang="id" hreflang="id">Bahasa Indonesia</a></li>
													<li class="interlanguage-link interwiki-it"><a href="//it.wikipedia.org/wiki/CPU_cache" title="CPU cache – Italian" lang="it" hreflang="it">Italiano</a></li>
													<li class="interlanguage-link interwiki-lv"><a href="//lv.wikipedia.org/wiki/Procesora_ke%C5%A1atmi%C5%86a" title="Procesora kešatmiņa – Latvian" lang="lv" hreflang="lv">Latviešu</a></li>
													<li class="interlanguage-link interwiki-mk"><a href="//mk.wikipedia.org/wiki/%D0%9A%D0%B5%D1%88_%D0%BC%D0%B5%D0%BC%D0%BE%D1%80%D0%B8%D1%98%D0%B0" title="Кеш меморија – Macedonian" lang="mk" hreflang="mk">Македонски</a></li>
													<li class="interlanguage-link interwiki-ja"><a href="//ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%83%A1%E3%83%A2%E3%83%AA" title="キャッシュメモリ – Japanese" lang="ja" hreflang="ja">日本語</a></li>
													<li class="interlanguage-link interwiki-no"><a href="//no.wikipedia.org/wiki/Hurtigminne" title="Hurtigminne – Norwegian (bokmål)" lang="no" hreflang="no">Norsk bokmål</a></li>
													<li class="interlanguage-link interwiki-pl"><a href="//pl.wikipedia.org/wiki/Pami%C4%99%C4%87_podr%C4%99czna_procesora" title="Pamięć podręczna procesora – Polish" lang="pl" hreflang="pl">Polski</a></li>
													<li class="interlanguage-link interwiki-pt"><a href="//pt.wikipedia.org/wiki/CPU_cache" title="CPU cache – Portuguese" lang="pt" hreflang="pt">Português</a></li>
													<li class="interlanguage-link interwiki-ru"><a href="//ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0" title="Кэш процессора – Russian" lang="ru" hreflang="ru">Русский</a></li>
													<li class="interlanguage-link interwiki-sk"><a href="//sk.wikipedia.org/wiki/R%C3%BDchla_vyrovn%C3%A1vacia_pam%C3%A4%C5%A5_procesora" title="Rýchla vyrovnávacia pamäť procesora – Slovak" lang="sk" hreflang="sk">Slovenčina</a></li>
													<li class="interlanguage-link interwiki-sr"><a href="//sr.wikipedia.org/wiki/%D0%9A%D0%B5%D1%88_%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%BD%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D0%BE%D1%80%D1%81%D0%BA%D0%B5_%D1%98%D0%B5%D0%B4%D0%B8%D0%BD%D0%B8%D1%86%D0%B5" title="Кеш централне процесорске јединице – Serbian" lang="sr" hreflang="sr">Српски / srpski</a></li>
													<li class="interlanguage-link interwiki-ta"><a href="//ta.wikipedia.org/wiki/%E0%AE%AA%E0%AE%A4%E0%AF%81%E0%AE%95%E0%AF%8D%E0%AE%95%E0%AF%81_%E0%AE%A8%E0%AE%BF%E0%AE%A9%E0%AF%88%E0%AE%B5%E0%AE%95%E0%AE%AE%E0%AF%8D" title="பதுக்கு நினைவகம் – Tamil" lang="ta" hreflang="ta">தமிழ்</a></li>
													<li class="interlanguage-link interwiki-zh"><a href="//zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98" title="CPU缓存 – Chinese" lang="zh" hreflang="zh">中文</a></li>
													<li class="uls-p-lang-dummy"><a href="#"></a></li>
											</ul>
				<div class='after-portlet after-portlet-lang'><span class="wb-langlinks-edit wb-langlinks-link"><a action="edit" href="//www.wikidata.org/wiki/Q352090#sitelinks-wikipedia" text="Edit links" title="Edit interlanguage links" class="wbc-editpage">Edit links</a></span></div>			</div>
		</div>
				</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 3 March 2015, at 16:18.</li>
											<li id="footer-info-copyright">Text is available under the <a rel="license" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a><a rel="license" href="//creativecommons.org/licenses/by-sa/3.0/" style="display:none;"></a>;
additional terms may apply.  By using this site, you agree to the <a href="//wikimediafoundation.org/wiki/Terms_of_Use">Terms of Use</a> and <a href="//wikimediafoundation.org/wiki/Privacy_policy">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a href="//www.wikimediafoundation.org/">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="//wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
											<li id="footer-places-contact"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
											<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Developers</a></li>
											<li id="footer-places-mobileview"><a href="//en.m.wikipedia.org/w/index.php?title=CPU_cache&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
											<li id="footer-copyrightico">
															<a href="//wikimediafoundation.org/"><img src="//bits.wikimedia.org/images/wikimedia-button.png" srcset="//bits.wikimedia.org/images/wikimedia-button-1.5x.png 1.5x, //bits.wikimedia.org/images/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation"/></a>
													</li>
											<li id="footer-poweredbyico">
															<a href="//www.mediawiki.org/"><img src="//bits.wikimedia.org/static-1.25wmf18/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="//bits.wikimedia.org/static-1.25wmf18/resources/assets/poweredby_mediawiki_132x47.png 1.5x, //bits.wikimedia.org/static-1.25wmf18/resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31" /></a>
													</li>
									</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"ext.globalCssJs.site":"ready","ext.globalCssJs.user":"ready","site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["ext.cite","mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.gadget.teahouse","ext.gadget.ReferenceTooltips","ext.gadget.DRN-wizard","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.switcher","ext.gadget.featured-articles-links","mmv.bootstrap.autostart","ext.imageMetrics.loader","ext.eventLogging.subscriber","ext.wikimediaEvents.statsd","ext.navigationTiming","schema.UniversalLanguageSelector","ext.uls.eventlogger","ext.uls.interlanguage"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"//bits.wikimedia.org/en.wikipedia.org/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=vector\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":81,"wgHostname":"mw1252"});
}</script>
	</body>
</html>
